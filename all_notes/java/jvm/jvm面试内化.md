##### 什么是双亲委派模型?为什么要用?
一个类加载器收到类加载的请求时不会先自己去加载,而是向上让其父加载器在自己范围内去查找,
找不到才会让子加载器加载该类

当出现了同名的字节码时能确保安全性,会优先去加载父加载器范围内的类

##### 什么是类加载器?
通过一个类的全限定名称来获取这个类的二进制字节流,就叫做类加载器

累加载器有
* 启动类加载器:用来加载java核心类库,比如jre/lib下的rt.jar无法被程序员直接引用(null)
* 扩展类加载器: 加载java扩展类库,这个类库是jre/lib/ext下的目录
* 系统类加载器:一般的java类由该加载器加载,像开发自己写的类
* 自定义类加载器:用来打破双亲委派机制的,创建一个类继承Classloader
![](img/Pasted%20image%2020221024020344.png)

##### 打破双亲委派的例子?为什么打破?
为了隔离加载的类
比如一个容器框架依赖的jar包可能会影响到另一中间件运行时使用jar包,此时用自定义类加载器加载
可以互不影响
两个模块依赖于一个库的不同版本用不同的类加载器加载,就可以互不干扰
像tomcat里每个webapp中的一些类库就用不同的类加载器进行隔离


##### 什么是jvm内存结构?
本地方法栈:
记录一些本地的native方法,java底层调用由c/c++实现的本地方法
当java里的某个线程要调用这些本地方法栈里的方法时不会在该线程的虚拟机栈里创建栈帧
而是用简单的动态链接直接调用
[动态链接库](../../clang/c程序的编译过程#####静态链接与动态链接)

方法区(元空间):
被所有线程共享
存放<font color=#F09B59 style=" font-weight:bold;">加载的类信息,常量,静态变量,常量池</font>
有的jvm放堆里

程序计数器:
记录jvm虚拟机执行的线程的字节码地址
时间片执行完后,切换线程能找到之前字节码执行到哪了

堆:
被所有线程共享
<font color=#66CC99 style=" font-weight:bold;">对象和数组</font>在堆上分配内存
一般在堆上进行垃圾回收优化

虚拟机栈:
线程私有的
每个方法执行都会创建一个栈帧
用于存储该方法的<font color=#66CC99 style=" font-weight:bold;">局部变量</font>,函数返回等
如果申请的栈深度大于虚拟机允许的最大深度会抛异常


##### 谈一谈jvm常量池?
class常量池和字符串常量池和基本类型包装类常量池

class常量池就是存类被加载进虚拟机后的各种字面量和符号引用,比如声明的final常量值,类型信息
字符串常量池就是底层用c++实现的Hashtable,用来存之前创建过的字符串
基本类型包装类常量池对一些小127的包装类(不包含Double和Float)的值负责创建
就是多次创建一样的值且小于127,则这个对象指向的引用就是一样的


##### 创建一个对象经历了哪些过程?
首先先去常量池里检查这个类的符号引用看这个类
是否有被加载,解析,初始化
如果没有就去磁盘利用类的全限定名去调用对应的类加载器进行加载
并为类的静态变量分配内存空间并设默认值
然后是解析该类
加载后对这个类进行检查,看是否符合规范,比如开头是不是魔数
比如其父类方法被final修饰,这个类不能重写该方法
接下来是初始化该类
<font color=#F09B59 style=" font-weight:bold;">调用类的clinit方法,为静态变量和常量赋值再去执行static代码块</font>

类的加载初始化完毕后
就是在堆内为实例对象分配内存空间,
[处理并发问题](JVM上篇：内存与垃圾回收篇/08-对象实例化及直接内存####3.处理并发问题)
并为实例变量赋默认值
[设置对象的对象头](JVM上篇：内存与垃圾回收篇/08-对象实例化及直接内存####5.设置对象的对象头)
然后调用<font color=#F09B59 style=" font-weight:bold;">构造器的init方法执行成员变量赋值,非静态代码块和构造方法</font>,先执行父类的
最后将堆区分配内存的这个地址引用给栈里的变量
总结:
类的加载解析初始化->对象的分配内存构造方法将地址给栈里引用

	 <clinit>方法是在类加载过程中执行的，而<init>是在对象实例化执行的，所以<clinit>一定比<init>先执 
    行。所以整个顺序为： 1.父类静态变量初始化 2.父类静态语句块 3.子类静态变量初始化 4.子类静态语句块 
    5.父类变量初始化块 6.父类语句块  7.父类构造函数 8.子类变量初始化块  9.子类语句块  10.子类构造 
    函数

>
##### 什么时候为发生栈内存溢出?
栈是每个线程私有的
每次方法执行都会创建栈帧
当有一个线程申请的栈深度超过虚拟机允许的最大深度就会抛栈溢出异常
但我们可以条-xss去调节栈大小

##### 方法中定义的局部变量是否线程安全？
不一定
得看这个局部变量有没有返回给外部
如果只是在方法内部产生,方法内部销毁
那就线程安全
如果返回给别的方法调用,那就是线程不安全的




