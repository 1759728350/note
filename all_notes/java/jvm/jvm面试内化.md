##### 什么是双亲委派模型?为什么要用?
一个类加载器收到类加载的请求时不会先自己去加载,而是向上让其父加载器在自己范围内去查找,
找不到才会让子加载器加载该类

当出现了同名的字节码时能确保安全性,会优先去加载父加载器范围内的类

##### 什么是类加载器?
通过一个类的全限定名称来获取这个类的二进制字节流,就叫做类加载器

累加载器有
* 启动类加载器:用来加载java核心类库,比如jre/lib下的rt.jar无法被程序员直接引用(null)
* 扩展类加载器: 加载java扩展类库,这个类库是jre/lib/ext下的目录
* 系统类加载器:一般的java类由该加载器加载,像开发自己写的类
* 自定义类加载器:用来打破双亲委派机制的,创建一个类继承Classloader
![](img/Pasted%20image%2020221024020344.png)

##### 打破双亲委派的例子?为什么打破?
为了隔离加载的类
比如一个容器框架依赖的jar包可能会影响到另一中间件运行时使用jar包,此时用自定义类加载器加载
可以互不影响
两个模块依赖于一个库的不同版本用不同的类加载器加载,就可以互不干扰
像tomcat里每个webapp中的一些类库就用不同的类加载器进行隔离


##### 什么是jvm内存结构?
本地方法栈:
记录一些本地的native方法,java底层调用由c/c++实现的本地方法
当java里的某个线程要调用这些本地方法栈里的方法时不会在该线程的虚拟机栈里创建栈帧
而是用简单的动态链接直接调用
[动态链接库](../../clang/c程序的编译过程#####静态链接与动态链接)

方法区(元空间):
被所有线程共享
存放<font color=#F09B59 style=" font-weight:bold;">加载的类信息,常量,静态变量,常量池</font>

程序计数器:
记录jvm虚拟机执行的线程的字节码地址
时间片执行完后,切换线程能找到之前字节码执行到哪了

堆:
被所有线程共享
<font color=#66CC99 style=" font-weight:bold;">对象和数组</font>在堆上分配内存
一般在堆上进行垃圾回收优化

虚拟机栈:
线程私有的
每个方法执行都会创建一个栈帧
用于存储该方法的<font color=#66CC99 style=" font-weight:bold;">局部变量</font>,函数返回等
如果申请的栈深度大于虚拟机允许的最大深度会抛异常


##### 谈一谈jvm常量池?
class常量池和字符串常量池和基本类型包装类常量池
class常量池就是存类被加载进虚拟机后的各种字面量和符号引用,比如声明的final常量值,类的全限定名
字符串常量池就是底层用c++实现的Hashtable,用来存之前创建过的字符串
基本类型包装类常量池对一些小127的包装类的值负责创建
就是多次创建一样的值且小于127,则这个对象指向的引用就是一样的










