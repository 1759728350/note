#### 小林coding自问自答

### 内存管理,管理个啥?
管理内存,这不是个废话吗
关键是内存里有啥啊
内存是cpu之前的指令和数据集散地
而指令和数据都属于进程的东西
那么内存分配解决的就是----进程占多少空间,往哪放更好


### 内存分段
##### 为什么要进行内存分段
功能上来说

程序之间不会相互覆盖,减少影响,起到一种隔离的效果
当然一个进程可以存在多个段
![](img/Pasted%20image%2020221001003516.png)

效率上来说
cpu从虚拟地址的第一个存储单元读到最后一个存储单元来找效率肯定低
分段后划出一块一块区域,就不用从头开始找,而是去那一块区域找,cpu访问内存的效率更高了
开了一块连续的内存,后续执行访问效率高


##### 物理地址和虚拟地址如何进行映射的?
段地址加偏移量来确定
cpu每次执行都会到段表里来找上述两个量来确定物理地址在哪
![](img/Pasted%20image%2020221001003540.png)
##### 内存分段会产生哪些问题呢?
内存分段带来了一些效率上和空间上的问题的问题
比如
	内存碎片
	内存交换的效率问题

内存碎片
![](img/Pasted%20image%2020221001010211.png)

一些小的不连续的内存碎片你之后读程序,因为其碎片本身很小,只有100MB,而你之后要读的有200MB,那它塞不进去,那只能造成内存空间的浪费

那吗操作系统就会使用内存交换的机制

### 内存交换技术
内存空间紧张时，系统将内存中某些进程暂时换出外存，
把外存中某些已具备运行条件的进程换入内存
中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存
[中级调度是什么](第二章_进程与线程###调度的层次)
![](img/Pasted%20image%2020220930234513.png)


##### 内存交换的效率问题
何为内存交换?
操作系统里有个swap分区,用以将这些不连续的存储在内存中的程序先读到硬盘中然后再读到内存中将原先的内存碎片给并掉了
同时你内存写到硬盘,以及硬盘读到内存,速度都特变慢,每次内存交换都邮箱性能

##### 进程应该被换到磁盘的哪里?
这就涉及到磁盘的两个概念
* 对换区
* 文件区

具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。
文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用<font color=#66CC99 style=" font-weight:bold;">离散分配</font>方式；
对换区空间只占磁盘空间的小部分，<font color=#F09B59 style=" font-weight:bold;">被换出的进程数据就存放在对换区</font>。
由于<font color=#66CC99 style=" font-weight:bold;">对换的速度直接影响到系统的整体速度</font>，因此对换区空间的管理主要追求换入换出速度，
因此通常对换区采用<font color=#66CC99 style=" font-weight:bold;">连续分配</font>方式（<font color=#99CCFF style=" font-weight:bold;">学过文件管理章节后即可理解</font>）。
总之，对换区的I/O速度比文件区的更快。

##### 内存什么时候应该交换？
交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。
例如：
在发现许<font color=#66CC99 style=" font-weight:bold;">多进程运行时经常发生缺页</font>，就说明<font color=#66CC99 style=" font-weight:bold;">内存紧张</font>，此时可以换出一些进程；
如果缺页率明显下降，就可以暂停换出。

##### 应该换出哪些进程？
可优先换出阻塞进程；可换出优先级低的进程；
为了防止优先级低的进程在被调入内存后很快又被换出，
有的系统还会考虑进程在内存的驻留时间

### 内存分配
##### 动态分区分配是什么?
首先其他分配内存的方式已经被淘汰
只剩下这个方式

内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。
外部碎片，是指内存中的某些空闲分区由于太小而难以利用。

动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，
而是在进程装入内存时，根据进程的大小动态地建立分区，
并使分区的大小正好适合进程的需要。

##### 动态分区分配的算法实现
![](img/Pasted%20image%2020221001000737.png)
![](img/Pasted%20image%2020221001000822.png)


### 内存分页
![](img/Pasted%20image%2020221001003759.png)
##### 为什么要进行内存分页?
因为要解决内存分段产生的内存交换问题
你利用swap分区进行内存交换来移动进程然后还需要重定位,代价太大
所以我们需要将进程也给打碎成页来有效利用这些内存碎片

同时我们的操作系统在内存不够用时,会将进程中不常用的页写回硬盘中,当需要是再写回来
![](img/Pasted%20image%2020221001003246.png)

##### 内存分页与内存分段区别?
内存分段将虚拟内存划区,起到隔离效果
内存分页将进程打碎,更高效的利用内存

页是信息的物理单位。分页的主要目的是为了<font color=#66CC99 style=" font-weight:bold;">实现离散分配，提高内存利用率</font>。
分页仅仅是<font color=#66CC99 style=" font-weight:bold;">系统管理上的需要</font>，完全是系统行为，对用户是不可见的。
段是信息的逻辑单位。分页的主要目的是更好地满足用户需求。
一个段通常包含着一组属于一个<font color=#66CC99 style=" font-weight:bold;">逻辑模块</font>的信息。
<font color=#66CC99 style=" font-weight:bold;">分段对用户是可见的，用户编程时需要显式地给出段名</font>。
页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。
分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。
分段的用户进程地址空间是二维的，程序员在标识一个地址时，
既要给出段名，也要给出段内地址

##### 多级页表为什么能节省空间?
首先每个进程都得有一个段表/页表来找打碎的指令/地址位置
我们要做的是将页表尽量做得小,节省内存空间
那么多级页表为什么可以呢?
局部性原理
你经常访问的指令/数据往往在一块
所以那些大部分不长访问的子页表我们不需要为其创建
假设4g虚拟内存
你只用一级页表,一行页表项4字节,一页大概4kB
那么页表项就会有4g/4kB=1024×1024=100w行
1024×1024×4B=4MB
一个进程就要有4MB来存页表,太浪费
多级存的话
分二级存的话
就是一级页表加部分二级用到的页表
一级页表不再存页的地址了,而是存二级页表的地址
假设该程序用到了四分之一的二级页地址
假设将原有一级页表分为1024个大小为1024B的二级页表,一页为1024B
总容量=1024行×4B+1/4×1024个子页表×1024行×4B = 4KB+1MB
占有内存是原先的1/3
![](img/Pasted%20image%2020221001010226.png)


### 什么是段页式内存管理?
就是结合分段和分页来打碎进程,然后进程根据表来寻找打碎的指令/数据的地址
先将一个进程根据功能存在不同的段中
然后把段打碎分页

![](img/Pasted%20image%2020221001010234.png)
![](img/Pasted%20image%2020221001010242.png)
补充
	堆段，每一个进程有一个，不论是主进程，动态库还是不同的线程里申请的堆内存，都反映在进程的堆段
	栈段，每一个线程有一个，如果进程有多个线程，则包含多个栈段
	代码段，由于其只读，不会被修改，故其在整个系统内共享。比如说一个执行文件，在系统中同时存在多个进程，那么这些进程将共享其代码段所占用的内存
	数据段，由于它是可写的，其内容与其所在的进程高度相关，所以在程序运行时会为每一个进程创建一个数据段的副本，故每个进程都有一个数据段
	-   数据段：存放数据的段。使用时候，用DS寄存器。
	-   程序段：用来存放程序的段。使用的时候，用CS和IP寄存器。
	-   栈段：是一个栈。使用时，初始设置SS和SP寄存器。
一个程序他本身就是包含不同的组成部分,比如main程序,变量,函数库,数组,对象

![](img/Pasted%20image%2020221001010255.png)
每个程序拥有其独特的一段内存空间来运行






##### 为什么linux取消了分段机制?
因为linux的开发者将段寄存器用以直接存储了所有线程的基址,而分段本质就是为了使不同段之间的程序相互影响
所以不用通过访问段来访问线程/进程了
同时引入了用户空间和内核空间这两个概念
当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。
在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。
在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址

由此看出linux开发者将linux把整个虚拟内存看成了一个段
同时将其分为两块地方:用户空间,内核空间
![](img/Pasted%20image%2020221001010303.png)
且这个空间的地址时连续的


##### 一个进程有哪些段组成
堆段，每一个进程有一个，不论是主进程，动态库还是不同的线程里申请的堆内存，都反映在进程的堆段
	栈段，每一个线程有一个，如果进程有多个线程，则包含多个栈段
	代码段，由于其只读，不会被修改，故其在整个系统内共享。比如说一个执行文件，在系统中同时存在多个进程，那么这些进程将共享其代码段所占用的内存
	数据段，由于它是可写的，其内容与其所在的进程高度相关，所以在程序运行时会为每一个进程创建一个数据段的副本，故每个进程都有一个数据段
	-   数据段：存放数据的段。使用时候，用DS寄存器。
	-   程序段：用来存放程序的段。使用的时候，用CS和IP寄存器。
	-   栈段：是一个栈。使用时，初始设置SS和SP寄存器。
一个程序他本身就是包含不同的组成部分,比如main程序,变量,函数库,数组,对象



### 内存映射文件
##### 什么是内存映射文件?
就是将文件映射到内存,映射一份
对这个内存操作就是对这个文件进行操作
这样就可以省去很多系统调用,将原来对于文件的操作转为对内存的操作,只要建立一个映射关系就行


传统的文件访问方式：
open 系统调用——打开文件
seek 系统调用——将读写指针移到某个位置
read 系统调用——从读写指针所指位置读入若干数据（从磁盘读入内存）
write 系统调用——将内存中的指定数据，写回磁盘（根据读写指针确定要写回什么位置）

内存映射文件的访问方式：
open 系统调用——打开文件
mmap 系统调用——将文件映射到进程的虚拟地址空间
![](img/Pasted%20image%2020221001005023.png)

