#### 小林coding自问自答

##### 内存管理,管理个啥?
管理内存,这不是个废话吗
关键是内存里有啥啊
内存是cpu之前的指令和数据集散地
而指令和数据都属于进程的东西
那么内存分配解决的就是----进程占多少空间,往哪放更好

##### 什么是进程
进程是指在系统中正在运行的一个应用程序
程序是静态的,进程是程序的动态表现
在线程与进程那一张再提

挖坑
[什么是守护进程](https://blog.csdn.net/qq_34629352/article/details/103489614?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166098819916782390598819%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166098819916782390598819&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-103489614-null-null.142^v42^new_blog_pos_by_title,185^v2^control&utm_term=%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88&spm=1018.2226.3001.4187)



##### 为什么要进行内存分段
功能上来说

程序之间不会相互覆盖,减少影响,起到一种隔离的效果
当然一个进程可以存在多个段


效率上来说
cpu从虚拟地址的第一个存储单元读到最后一个存储单元来找效率肯定低
分段后划出一块一块区域,就不用从头开始找,而是去那一块区域找,cpu访问内存的效率更高了
开了一块连续的内存,后续执行访问效率高


##### 物理地址和虚拟地址如何进行映射的?
段地址加偏移量来确定
cpu每次执行都会到段表里来找上述两个量来确定物理地址在哪

##### 内存分段会产生哪些问题呢?
内存分段带来了一些效率上和空间上的问题的问题
比如
	内存碎片
	内存交换的效率问题

内存碎片
![[Pasted image 20220820170650.png]]

一些小的不连续的内存碎片你之后读程序,因为其碎片本身很小,只有100MB,而你之后要读的有200MB,那它塞不进去,那只能造成内存空间的浪费

那吗操作系统就会使用内存交换的机制

##### 内存交换的效率问题
何为内存交换?
操作系统里有个swap分区,用以将这些不连续的存储在内存中的程序先读到硬盘中然后再读到内存中将原先的内存碎片给并掉了
同时你内存写到硬盘,以及硬盘读到内存,速度都特变慢,每次内存交换都邮箱性能

##### 为什么要进行内存分页?
因为要解决内存分段产生的内存交换问题
你利用swap分区进行内存交换来移动进程然后还需要重定位,代价太大
所以我们需要将进程也给打碎成页来有效利用这些内存碎片

同时我们的操作系统在内存不够用时,会将进程中不常用的页写回硬盘中,当需要是再写回来

##### 内存分页与内存分段区别?
内存分段将虚拟内存划区,起到隔离效果
内存分页将进程打碎,更高效的利用内存

##### 什么是段页式内存管理?
就是结合分段和分页来打碎进程,然后进程根据表来寻找打碎的指令/数据的地址
先将一个进程根据功能存在不同的段中
然后把段打碎分页

![[Pasted image 20220820212119.png]]
![[Pasted image 20220820212150.png]]
补充
	堆段，每一个进程有一个，不论是主进程，动态库还是不同的线程里申请的堆内存，都反映在进程的堆段
	栈段，每一个线程有一个，如果进程有多个线程，则包含多个栈段
	代码段，由于其只读，不会被修改，故其在整个系统内共享。比如说一个执行文件，在系统中同时存在多个进程，那么这些进程将共享其代码段所占用的内存
	数据段，由于它是可写的，其内容与其所在的进程高度相关，所以在程序运行时会为每一个进程创建一个数据段的副本，故每个进程都有一个数据段
	-   数据段：存放数据的段。使用时候，用DS寄存器。
	-   程序段：用来存放程序的段。使用的时候，用CS和IP寄存器。
	-   栈段：是一个栈。使用时，初始设置SS和SP寄存器。
一个程序他本身就是包含不同的组成部分,比如main程序,变量,函数库,数组,对象

![[Pasted image 20220820155636.png]]
每个程序拥有其独特的一段内存空间来运行



##### 多级页表为什么能节省空间?
首先每个进程都得有一个段表/页表来找打碎的指令/地址位置
我们要做的是将页表尽量做得小,节省内存空间
那么多级页表为什么可以呢?
局部性原理
你经常访问的指令/数据往往在一块
所以那些大部分不长访问的子页表我们不需要为其创建
假设4g虚拟内存
你只用一级页表,一行页表项4字节,一页大概4kB
那么页表项就会有4g/4kB=1024×1024=100w行
1024×1024×4B=4MB
一个进程就要有4MB来存页表,太浪费
多级存的话
分二级存的话
就是一级页表加部分二级用到的页表
一级页表不再存页的地址了,而是存二级页表的地址
假设该程序用到了四分之一的二级页地址
假设将原有一级页表分为1024个大小为1024B的二级页表,一页为1024B
总容量=1024行×4B+1/4×1024个子页表×1024行×4B = 4KB+1MB
占有内存是原先的1/3
![[Pasted image 20220820211623.png]]



##### 为什么linux取消了分段机制?
因为linux的开发者将段寄存器用以直接存储了所有线程的基址,而分段本质就是为了使不同段之间的程序相互影响
所以不用通过访问段来访问线程/进程了
同时引入了用户空间和内核空间这两个概念
当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。
在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。
在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址

由此看出linux开发者将linux把整个虚拟内存看成了一个段
同时将其分为两块地方:用户空间,内核空间
![[Pasted image 20220821025320.png]]
且这个空间的地址时连续的

##### 一个进程占3g内存?
不是的,用户空间3g表示该进程在用户空间下能访问的范围是3g内存,并不是其实际占有的内存
所以用户空间不止一个进程
32位操作系统下其进入内核态的寻址能力为4g

##### 一个进程有哪些段组成
堆段，每一个进程有一个，不论是主进程，动态库还是不同的线程里申请的堆内存，都反映在进程的堆段
	栈段，每一个线程有一个，如果进程有多个线程，则包含多个栈段
	代码段，由于其只读，不会被修改，故其在整个系统内共享。比如说一个执行文件，在系统中同时存在多个进程，那么这些进程将共享其代码段所占用的内存
	数据段，由于它是可写的，其内容与其所在的进程高度相关，所以在程序运行时会为每一个进程创建一个数据段的副本，故每个进程都有一个数据段
	-   数据段：存放数据的段。使用时候，用DS寄存器。
	-   程序段：用来存放程序的段。使用的时候，用CS和IP寄存器。
	-   栈段：是一个栈。使用时，初始设置SS和SP寄存器。
一个程序他本身就是包含不同的组成部分,比如main程序,变量,函数库,数组,对象


##### 页表的作用
对进程的内存访问进行指导和限制
