
### 什么是操作系统

<font color=#FF6666* style=" font-weight:bold;">总结</font>
> 能载入程序到内存中并对程序进行更高效利用cpu/和内存的管理程序
> ,包括为程序提供一些系统调用api,诸如:文件/进程/管道以及操纵这些的api


多程序加入到内存中时就产生了一个概念
#### 进程
当几个程序加载入内存中,需要对程序进行隔离,万一某个程序出现bug其指针指向另一个程序,将另一个程序的的变量改了
一个程序就会将其他程序破坏掉

多程序并行执行就产生一个概念
#### 中断
一个基于时钟的分时切片,一种cpu调度策略
谁优先级高谁先执行多少秒再切换到b'查询执行100ms
当a程序执行io/网络连接等待暂时不用cpu进行计算,就调度b程序使用cpu

后续出现了一下概念
信号
管道(对象)
grep(应用程序)
虚拟化硬件


### 什么是程序和编译器
一个操作系统上的程序是比如说c程序其本质相当于一个状态机
状态机即为一种有限个状态以及在这些状态转移和动作的数学计算模型
c程序本质是一个状态机,其预处理,编译成汇编程序后,汇编程序本质也是状态机
c程序通过堆/栈,进行全局变量的变化,函数调用和返回,debug从一个状态到另一个状态
汇编也是如此,其通过操作memory/寄存器来状态改变
c程序中能灵活加入汇编代码,我们不需要直接写汇编,汇编往往用c程序转变过来
在这里了解汇编是为了进一步探索操作系统
状态的迁移就是指令的执行
![](img/Pasted%20image%2020220802234829.png)
编译器
我们要知道有编译器的存在
在c程序编译为汇编时会做编译优化
一些不可被优化的操作会被跳过,一些需要被优化的操作会进行合并/化简

![](img/Pasted%20image%2020220731010050.png)
c程序
汇编
系统调用
这些是不在一个层面上的,一路由编译器向下解释的

![](img/Pasted%20image%2020220731011929.png)
对于应用视角来说,操作系统就是一个syscall指令,这个syscall具体如何调用系统api,应用程序角度是看不到的
一个程序不访问系统调用,那该程序只能进行计算
![](img/Pasted%20image%2020220731012829.png)

能够追踪调试程序,看懂英文文档,是一个计算机从业者质变的重要因素



### 多处理器编程,多线程
从操作系统来看待多线程,各种不同的上层应用都能并发的向下进行系统调用
从计算机的演变来看,最早的多线程程序就是操作系统本身的系统调用


通过状态机的视角来看待多线程
本质就是多个栈链表以及共用的全局变量和堆(存放结构体引用)
局部变量存放在栈的某个链表节点上
相较于单线程,多线程的状态机是不稳定的,每个线程都存在随机性,但我们的目的是要得到稳定的结果

下面的程序你直接写两个while死循环,程序只会停留在第一个死循环中
要借用thread.h线程库来创建a,b两个线程,才能达到多线程并发的效果
操作系统会自动将两个线程放置在不同的处理器上,同时后台cpu的使用率会超过百分制一百:200%
![](img/Pasted%20image%2020220731131255.png)


#### 原子性丧失
何为原子性
<font color=#FF6666* style=" font-weight:bold;">一系列的操作，要么全部执行成功，要么全部不执行，不会出现执行一半的情况，是不可分割的，这种特性被称之为原子性</font>

<font color=#66CC99 style=" font-weight:bold;">线程的切换，带来了原子性问题</font>
并发编程必须面临的问题
过去"程序或指令独占处理器执行"的基本假设在现代多处理器上不再成立

原子性(互斥性): 一段代码独占整个计算机系统
![](img/Pasted%20image%2020220731164524.png)
没有原子性,多线程代码会乱套,即使一个求和操作也无法完成
![](img/Pasted%20image%2020220731163146.png)

##### Dekker’s algorithm
——一个实现锁的算法
> 是实现锁的一种算法。这种算法只解决两个线程竞争资源的情况。为了不让两个线程同时执行一段代码，比较直观的方案是设一个共享bool变量，线程进入前先检测它的值，有线程进入后改变它的值。但是在并发的情况下，可能在A检查完认为B没进入，准备改备值前，B也检测完了，这时候就两个线程都进入了。为了解决这个问题AB应该能够知道对方的情况，所以把一个BOOL变量变成两个BOOL变量，分别表示AB是否已经到这个区域。这时候怎么决定谁先继续走下去呢？要增加一个BIT，等于0表示A,等于1表示B，A,B进入后都把这个值改成它们对应的值，在决定往下走前，再回头检查一下这个值，看有没有被别人改了，如果被对方改了，则让对方先走。如果没被对方改，则认为自己仍然应该走，但是在对方放弃之前，不继续往下走。这时候会不会两个人都不往下走呢？不会的，因为那个BIT不是0就是1，所以总有一个人放弃的。也有一种可能是对方已经进入临界区，这时候对方就会一直执行到结束才修改自身状态，另一个线程才能往下走。

从上面的算法可以看出并发编程的算法以及难度要求相当之大




从手册中我们可以看出printf是实现了线程安全的
![](img/Pasted%20image%2020220731164833.png)

并发编程的现代处理方式
![](img/Pasted%20image%2020220731165355.png)
并发编程一般采用工程化的,现有实现好的编程工具来开发,高效率的处理方式往往会使得程序失控
##### 并发编程工具
	线程池
	队列
	map-reduce






#### 顺序的丧失
编译器对内存访问的"最终一致性"处理方式导致内存共享作为线程同步失效
对内存的优化直接往结果优化一步到位了
比如b线程等待a线程的值到10执行,但a的结果判定是到100停下
那么a会直接一步到位后将值写入到内存,没有经过a的值等于10这个结果
你想啊,每次a++都写入到a的内存,程序不是很慢吗,编译器将内存的访问直接优化掉了
所以如果把这个值作为标记来进行线程同步,那么很可能a线程在结束后b线程任然不执行,因为a没有被
赋值过10,直接被赋值为100了
![](img/Pasted%20image%2020220731183719.png)