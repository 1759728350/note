### 什么是进程同步?
首先要知道进程异步是什么
##### 进程异步
各个并发进程自顾自的独立运行,不管其他进程的死活,推进运行
并发必然导致异步性(并发必然导致<font color=#F09B59 style=" font-weight:bold;">混乱</font>,混乱到一定程度就不可预测)
异步执行也可以理解为混乱执行
##### 进程同步
确定多个并发进程的先后
比如写进程和读进程
管道通信就必须保证写进程在读进程之前
也就是说<font color=#FF6666* style=" font-weight:bold;">进程同步是为了防止多个并发进程运行混乱,而来协调次序的</font>
![](img/Pasted%20image%2020220921164327.png)

### 进程互斥
##### 进程互斥和进程同步区别?
两者不是同一层面上的概念
同步是基于互斥的
或者说,同步是由互斥实现的
互斥仅仅只实现了<font color=#F09B59 style=" font-weight:bold;">排他性</font>
而同步还要解决<font color=#66CC99 style=" font-weight:bold;">顺序</font>的问题,谁在前,谁在后
也就是说我们要<font color=#FF6666* style=" font-weight:bold;">在实现了互斥的基础上还要解决异步性才能实现同步</font>


##### 共享资源
进程的并发肯定会遇到多个进程获取同一个资源的问题
这个资源叫做共享资源

这个共享资源包括两种截然不同的共享方式
* 互斥共享
* 同时共享

##### 互斥共享
虽然这个资源可以给多个进程共享获取
但<font color=#66CC99 style=" font-weight:bold;">一个时间段内只能一个进程访问该资源</font>
采用互斥共享方式的资源就是<font color=#66CC99 style=" font-weight:bold;">临界资源</font>
[临界资源](第二章_进程与线程#####什么是临界资源?)

##### 同时共享
一个时间段内多个进程都可以对该资源获取访问

##### 设计进程互斥的原则
1．空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;
2．忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;
3．有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿)
4．让权等待。当进程<font color=#66CC99 style=" font-weight:bold;">不能进入临界区时，应立即释放处理机，防止进程忙等待</font>。

![](img/Pasted%20image%2020220921171431.png)

### 进程互斥的实现
#### 软件层面实现
* 单标志
* 双标志
* 双标志后检查
* Peterson算法
根据<font color=#99CCFF style=" font-weight:bold;">蒋炎岩的操作系统课</font>上的三种软件层面实现互斥的算法
其局限太大
即使是最厉害的Peterson算法利用复杂的逻辑判断也<font color=#66CC99 style=" font-weight:bold;">只能实现两个进程的互斥</font>
因为在<font color=#F09B59 style=" font-weight:bold;">多处理器并发状态</font>下
多进程的运行状态是极为<font color=#66CC99 style=" font-weight:bold;">混乱的,基本无法做到同步</font>
用于检测其他进程是否进入临界区的标志位也难以防住
<font color=#66CC99 style=" font-weight:bold;">a进程还没来得及修改标志位,另一个进程就直接进去了</font>


#### 硬件层面实现
* 中断屏蔽
* TSL锁
* swap指令
##### 中断屏蔽
单处理器cpu下可以

中断无法应用域多处理器环境
因为关中断只对关闭中断的那个处理器有用
其他处理器该访问临界区还是能访问
![](img/Pasted%20image%2020220921224737.png)

而且也不适合用户进程使用,因为开关中断都需要切换到内核态才能用,
你一个普通用户进程就能随意使用系统调度相关的中断指令岂不是很危险?

##### TestAndSetLock指令
相比软件实现方法，TSL指令把“上锁”和“检查操作用硬件的方式变成了一气呵成的原子操作
硬件层面实现,所以下面是用c模拟逻辑
```c
//布尔型共享变量lock表示当前临界区是否被加锁
//true表示已加锁，false表示未加锁
bool TestAndSet (bool *lock){
	bool old;
	old = *lock;//old用来存放lock原来的值,用来返回
	*lock = true;//无论之前是否加锁,都将共享变量lock的值设为true
	return old;//返回lock原来的值
}
```
```c
//以下是使用TSL指令实现互斥的算法逻辑
while (TestAndSet(&lock)); //"上锁"并"检查"
临界区代码段...
lock = false;//“解锁"
剩余区代码段...
```
硬件层面上实现的,涉及到总线和寄存器
就不会出现进程层面的异步混乱问题

缺点:不满足“让权等待”原则，暂时无法进入临界区的进程会占用cpu并循环执行TSL指令，从而导致“<font color=#66CC99 style=" font-weight:bold;">忙等</font>”

### 锁
##### 锁是什么?
多线程下访问临界资源时实现互斥/同步的机制

##### 锁是怎么实现的?
由多个信号量/互斥量对资源进行占有,该操作是原子操作(<font color=#F09B59 style=" font-weight:bold;">具体为PV操作</font>)

##### 互斥锁
对于各程序临界区访问临界资源问题
最简单的解决工具就是互斥锁
互斥锁里有一个available变量,锁被某个进程获取后就改为false
被释放后改为true
<font color=#FFCCCC style=" font-weight:bold;">那么被获取这个行为,以及锁的获取和被释放怎么描述?</font>
那就用一个acquire()函数,当锁被获取时,就调用该函数,将available设为false
available代表锁是否被获取,与释放(release函数)

当一个进程去试图获取一个不可获取的锁(调用acquire),就会<font color=#F09B59 style=" font-weight:bold;">阻塞</font>
<font color=#66CC99 style=" font-weight:bold;">直到该锁被其他进程释放</font>
```java
acquire()
	while(!available)//其他进程想获取锁一直处于忙等待
	available = false;//获得锁
}

release() {
	available = true;//释放锁
}
```
因为这个过程必须是<font color=#66CC99 style=" font-weight:bold;">原子操作</font>,且是硬件层面实现的
[何为原子操作](../../principle_of_computer_organization/王道计组/第六章_总线和io###什么是原子操作)

缺点:
互斥锁在被一个进程进入临界区获取锁后
其他进程只能只能不停循环调用acquire()来获取锁,处于<font color=#66CC99 style=" font-weight:bold;">忙等待</font>状态
(注意:这里的忙等待是一个互斥设计的概念,不要和阻塞搞混了)
因此互斥锁一般用于<font color=#F09B59 style=" font-weight:bold;">多处理器系统</font>
一个处理器每次分时间片给一个忙等待程序执行,很浪费,本来就只有一个核,到你了还啥事不干
多个处理器的话,你让一个闲置的处理器去分配时间片给一直获取锁的进程忙等待也可以接受

##### 自旋锁
需要<font color=#F09B59 style=" font-weight:bold;">连续循环忙等</font>的互斥锁就叫做自旋锁
如果其他进程释放锁快的话,效率就更高

优点:
直接一路忙等下去,一条路走到黑
也不切换进程上下文了,因此对于那些能快速获取到锁,等待代价更低(因为切换别的进程上来)
但随着忙等时间越来越长,开销越来越大

### 信号量
##### 信号量是什么东西呢?
<font color=#F09B59 style=" font-weight:bold;">描述系统中哦共享资源的数量</font>
可以理解为信号量就是资源
因此不同资源要设置不同的信号量
也可以理解为<font color=#66CC99 style=" font-weight:bold;">进入临界区的名额</font>

尝试思考一下,之前软件层面上实现互斥,是很难做到的
比如单标志,双标志,都面临一个问题:
<font color=#66CC99 style=" font-weight:bold;">"检查"和"上锁"这两个操作不能一气呵成的完成</font>,以至于多个进程进入到了<font color=#66CC99 style=" font-weight:bold;">临界区</font>

信号量使用PV原语实现的
[原语是什么](第二章_进程与线程#####原语是什么)

##### PV操作是什么?
pv是荷兰语开头,分别是wait和signal原语
因为wait和signal是原语
p操作:进程想申请资源
v操作:进程想释放资源
所以可以将他们这整个函数视为原子操作
因此<font color=#66CC99 style=" font-weight:bold;">解决了之前的"检查"和"上锁"无法一气呵成的缺点</font>

##### 整型信号量
用一个整数型的变量作为信号量，用来表示系统中某种资源的数量.
某计算机系统中有一台打印机
```c
int s = 1;//初始化整型信号量s，表示当前系统中可用的打印机资源数
void wait (int S){// wait原语，相当于”进入区”
	while (S = 0);
	//如果资源数不够，就一直循环等待
	S=S-1;
	//如果资源数够，则占用一个资源
}
void signal (int S) { //signal原语，相当于“退出区”
	S=S+1;
	//使用完资源后，在退出区释放资源
}
```
![](img/Pasted%20image%2020220922225038.png)

因为一个进程获取到了锁后,其他进程只会不停的while循环
会产生<font color=#66CC99 style=" font-weight:bold;">忙等</font>问题,不满足互斥设计的"<font color=#66CC99 style=" font-weight:bold;">让权等</font>待"原则

##### 记录型信号量
<font color=#FFCCCC style=" font-weight:bold;">那如何解决忙等呢?</font>
创建一个阻塞队列
那些本来要陷入while循环的,现在不再循环了,而是加入到阻塞队列
等待被<font color=#66CC99 style=" font-weight:bold;">唤醒</font>
```c
/*记录型信号量的定义*/
typedef struct{
	int value;
	//剩余资源数
	struct process *L;
	//等待队列
}semaphore;

/*某进程需要使用资源时，通过wait原语申请*/
void wait(semaphore S){
	s.value--;
	if (S.value < 0){
		block(S.L);
	}
}
```
block原语
如果剩余资源数不够,使用block原语使进程从运行态进入阻塞态，
并把挂到信号量S的等待队列（即<font color=#F09B59 style=" font-weight:bold;">阻塞队列</font>）中
```c
/*进程使用完资源后，通过signal原语释放*/
void signal(semaphore S){
	S.value++;
	if(S.value <= 0){
		wakeup(S.L);
	}
}		

```
资源被释放后
会调用wakeup原语
从阻塞队列中<font color=#66CC99 style=" font-weight:bold;">唤醒之前被阻塞的进程</font>
重新进入临界区获取资源
![](img/Pasted%20image%2020220922232409.png)

### 信号量实现进程同步
同步是基于互斥的
那么
##### 信号量如何实现进程互斥?
就是上面介绍的两种方式
* 初始化信号量
* 进入区加锁申请资源
* 临界区使用资源
* 退出去释放资源,释放锁
![](img/Pasted%20image%2020220922233439.png)

##### 实现实现同步
思考:
互斥是解决了,但异步性问题仍然存在
那么<font color=#FFCCCC style=" font-weight:bold;">如何保证一前一后呢?</font>
可以围绕着资源来
先设置一个资源,信号量为0
只在对应进程的某一段代码进行V操作释放资源
那么别的进程(p2)在进行P操作获取该资源时就会阻塞(S - 1 < 0)
到轮到p1进程执行到V操作时就会释放资源S+1,
此时S >= 0,同时会唤醒p2进程执行
![](img/Pasted%20image%2020220923004140.png)

前驱关系考题:
![](img/Pasted%20image%2020220923004832.png)



### 生产者消费者问题
这是一个对于信号量实现互斥和同步的深入案例

消费者释放的资源可以理解为缓冲区<font color=#66CC99 style=" font-weight:bold;">空间资源</font>
生产者释放的资源可以理解为缓冲区数据资源
![](img/Pasted%20image%2020220923125309.png)

为什么不能把同步信号量的PV操作放在互斥信号量中呢(<font color=#66CC99 style=" font-weight:bold;">不能放入临界区内</font>)
因为互斥信号量保证了进程临界区的互斥运行
而在这一段运行时间内其他进程干预不了
一旦你需要其他资源释放进程
和你实现互斥的进程因为你访问了临界区,他就访问不了了
因此会陷入<font color=#F09B59 style=" font-weight:bold;">死锁</font>问题


##### 多生产者多消费者问题
在缓冲区大于1的情况下,需要加互斥信号量,否则会产生<font color=#F09B59 style=" font-weight:bold;">覆盖</font>问题
我能我们会有一个疑问:
<font color=#FFCCCC style=" font-weight:bold;">为什么要加互斥信号量?</font>
因为当他知识一个盘子,那么这就可以视作为一个简单的资源
一个同步信号量就能代表该资源
当一个盘子的时候
这个空间资源就只有一个,那么此时用一个同步信号量就可以解决互斥访问的问题
当有多个盘子时
就有多个空间资源,那这个盘子就是个复杂结构
一个复杂结构就不是用一个同步信号量就能解决的
![](img/Pasted%20image%2020220923131926.png)


###  吸烟者问题
主要解决的就是<font color=#F09B59 style=" font-weight:bold;">单生产者,多消费者的并发同步问题</font>
生产者能生产出多种不同的产品,消费者能并发的获取
![](img/Pasted%20image%2020220923185926.png)

### 读者写者问题
有读者和写者两组并发进程，共享一个文件，
当两个或两个以上的读进程同时访问共享数据时不会产生副作用，
但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。
因此要求:
①允许多个读者可以同时对文件执行读操作;
②只允许一个写者往文件中写信息;
③任一写者在完成写操作之前不允许其他读者或写者工作;
④写者执行写操作前，应让已有的读者和写者全部退出。

![](img/Pasted%20image%2020220923201941.png)
要实现<font color=#66CC99 style=" font-weight:bold;">读进程和写进程的互斥</font>
又要实现读进程与读进程之间<font color=#66CC99 style=" font-weight:bold;">不互斥</font>
同时又<font color=#66CC99 style=" font-weight:bold;">要确保读进程对于count变量的互斥访问</font>
<font color=#FFCCCC style=" font-weight:bold;">为什么读进程要对count变量就行互斥访问呢?</font>
因为你要实现读写进程互斥,你就要确保读进程数量在变为0后能释放锁
以及第一个读进程启动后要获取锁,这都涉及到对count的访问
多个多进程需要对count的值修改,因此要对该值设置互斥信号量

<font color=#FFCCCC style=" font-weight:bold;">如何保证多个读进程之间不互斥?</font>
这就要理解,
在什么情况下,在什么情况下进程才会互斥?
<font color=#F09B59 style=" font-weight:bold;">设置了同一个互斥信号量的情况下进程之间才会互斥</font>
不同信号量之间没影响
那么对于多个读进程之间,不需要互斥
那么只需要除第一个读进程以外的其他读进程不再获取有关于读写进程的互斥信号量
跳过P(rw)这行代码,直接去读文件
<font color=#66CC99 style=" font-weight:bold;">不获取锁,自然就不会互斥了</font>
![](img/Pasted%20image%2020220923201821.png)

##### 写进程优先(读写公平)
源源不断的读进程到来,写进程阻塞,一直执行不了,就会饿死
因为<font color=#66CC99 style=" font-weight:bold;">读进程不互斥,一次可以执行很多个</font>
因此后来的读进程也占了便宜,即使比写进程到来的快,也仍然没有释放锁
写进程即使比后面读进程到来的快也是最后一个执行
不公平!
怎么办?
那么我们可以用一个信号量<font color=#F09B59 style=" font-weight:bold;">实现读写公平</font>
由于后续的读进程源源不断到来
假设写进程是第二个执行的(虽然并发状态下,但总有个预期上的先来后到)
那你第三个读进程就会抢占写进程的执行机会
那么怎样按顺序执行读写呢?
新创建一个信号量,上锁
我们可以在每一次<font color=#66CC99 style=" font-weight:bold;">读文件这个节点释放锁</font>
然后如果接下来是写进程来了
那么写进程就会执行P(w),<font color=#66CC99 style=" font-weight:bold;">先将锁给占了</font>
后来的读进程就因为写进程没有释放锁,自然无法向下执行
当之前的几个读进程全部执行完毕count等于0后
释放rw锁后
写进程就可以执行了
写进程执行完毕后,释放w锁
接下来就可以执行在写进程之后到来的读进程了
![](img/Pasted%20image%2020220923232305.png)

##### 对于PV操作的感悟
<font color=#FFCCCC style=" font-weight:bold;">如何取把控复杂的并发同步的流程呢?</font>
对于同一信号量来说
<font color=#F09B59 style=" font-weight:bold;">a进程的V操作可以视作传送门,传送到其他进程同一信号量的P位置</font>
或者<font color=#F09B59 style=" font-weight:bold;">上部分代码的P位置</font>


### 哲学家吃饭问题
面对多个临界资源的并发同步问题
每个哲学家都用一个mutex互斥信号量,<font color=#F09B59 style=" font-weight:bold;">来保证哲学家之间互斥执行(排队执行)</font>
对于每个筷子也设置对于的信号量,根据索引设置
哲学家获取到了筷子就对对应的筷子上锁
流程模拟:
0号哲学家拿了两个筷子,然后释放mutex锁
其他哲学家可以动了
四号哲学家拿了左边的筷子,右边的筷子拿不了
陷入阻塞,同时没有执行V(mutex),因此其他哲学家动不了
直到0号哲学家吃完饭释放了两个筷子
4号哲学家被唤醒,获取到了右边的筷子,然后执行V(mutex)释放锁
其他哲学家又可以动了
2号哲学家尝试获取筷子........4号吃完饭释放筷子.......
![](img/Pasted%20image%2020220924003512.png)



### 管程
<font color=#FFCCCC style=" font-weight:bold;">什么是管程?</font>
管程就是用来<font color=#66CC99 style=" font-weight:bold;">更加便捷的使用信号量实现互斥</font>的方式
当多个进程去访问一个共享变量时
你不得不用复杂的信号量去实现进程互斥访问,这非常复杂
而访问的这个操作本身可以视为一个函数
在面向对象的语言里
这就相当于一个对象封装的方法
管程的主要运用体现在synchronized
对<font color=#F09B59 style=" font-weight:bold;">一个方法用synchronized修饰后,其他进程互斥地调用这个方法</font>
相当于<font color=#FF6666* style=" font-weight:bold;">多个进程只能互斥地执行这个行为</font>

主要运用了面向对象的思想
<font color=#66CC99 style=" font-weight:bold;">将互斥的实现封装到来行为里</font>
<font color=#66CC99 style=" font-weight:bold;">从而使调用的进程不需要考虑互斥问题</font>,
直接调用


##### 管程对于生产者消费者问题的优化
![](img/Pasted%20image%2020220930191514.png)
原先放在consumer和producer里的互斥逻辑给放在了一个新的类里
每次生产者和消费者直接去调用该类的方法就不用考虑互斥问题了

##### java中的synchronized
```java
static class monitor {i
	private Item buffer[] = new Item[N];
	private int count = 0;
	//多个进程排队调用该方法
	public synchronized void insert (Item item) {
	
	}
}
```

