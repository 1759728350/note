### 互斥锁好自旋锁
[信号量实现互斥锁和自旋锁](第三章_进程互斥与同步###锁)

### 什么是死锁
多个进程都在等待对方手里的资源,都停下来了
互相死循环了
本质还是每个进程都需要多个互斥的资源
而这些互斥的资源被占有了,而每个进程都没全部获取到,
导致<font color=#66CC99 style=" font-weight:bold;">资源既获取不到,又无法执行释放不了</font>

##### 饥饿和死锁的区别
饥饿和死锁的由来都是源于操作系统分配资源不合理导致的

饥饿
由于不太完善的调度算法导致进程一直无法得到执行
可能陷入到阻塞态,也可能被调到外存,挂起了,(长期得不到需要的io设备资源,排队一直等)
也有可能一直处于就绪态,优先级太低,一直无法得到执行

死锁
区别饥饿,足够多的时间等待,可能就能执行了
"饥饿"但不"饿死"
死锁问题就是多个进程争抢对方手里的资源
导致谁也执行不了
问题比较严重


### 死锁产生的必要条件
必要条件就是这是个缺一不可
* 互斥条件:
该资源只能一次被一个线程获取

* 不可抢占条件：
其他线程不能强行抢占线程T1占有的资源

* 请求和保持条件：
线程T1已经获取共享资源a，在等待共享资源b的时候，不释放共享资源a

* 循环等待条件：
线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，这形成了循环等待。

总而言之:
对多个共享互斥资源的竞争
多个进程推进顺序设计错误


### 死锁的检测
在现实开发环境下,进程太多了
想要找到死锁的进程比较难,要用到专业的性能检测工具
不过最重要的还是在设计阶段就尽量避免死锁
![](img/Pasted%20image%2020220930212920.png)

### 如何解除死锁
1. 资源剥夺法。<font color=#F09B59 style=" font-weight:bold;">挂起</font>（暂时放到外存上）某些死锁进程，并<font color=#66CC99 style=" font-weight:bold;">抢占它的资源</font>，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。

2. 终止进程法, 强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。

3. 进程回退法。让一个或多个死锁进程<font color=#66CC99 style=" font-weight:bold;">回退到足以避免死锁的地步</font>。这就要求系统要记录进程的历史信息，<font color=#66CC99 style=" font-weight:bold;">设置还原点</font>。


### 如何避免死锁
##### 什么是安全序列
这个概念主要是为了避免死锁
系统如何分配资源才能使并行的进程都能顺利执行完毕

这就涉及到银行家算法

##### 什么是银行家算法
系统根据你这个进程已经占有的资源和需要的资源来进行评估
如果给你这个资源后你能满足执行完毕,然后全释放了
其他更多的进程就能利用那些释放的资源
如果你这个进程缺的资源太多了
要是系统此时分配给你许多资源的同时,你还没满足顺利执行的条件
其他进程也要获取这些资源
那么你这进程既占有了一堆资源,又无法顺利执行释放
其他进程又因为系统分配给了你而只能阻塞等待
就会产生死锁
因此银行家算法就是评估
然后挑选出适合优质的进程
贷出资源
然后获取释放的资源
![](img/Pasted%20image%2020220930230628.png)
