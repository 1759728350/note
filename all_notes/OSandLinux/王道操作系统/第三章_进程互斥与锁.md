### 什么是进程同步?
首先要知道进程异步是什么
##### 进程异步
各个并发进程自顾自的独立运行,不管其他进程的死活,推进运行
并发必然导致异步性(并发必然导致<font color=#F09B59 style=" font-weight:bold;">混乱</font>,混乱到一定程度就不可预测)
异步执行也可以理解为混乱执行
##### 进程同步
确定多个并发进程的先后
比如写进程和读进程
管道通信就必须保证写进程在读进程之前
也就是说<font color=#FF6666* style=" font-weight:bold;">进程同步是为了防止多个并发进程运行混乱,而来协调次序的</font>
![](img/Pasted%20image%2020220921164327.png)

### 进程互斥
##### 进程互斥和进程同步区别?
两者不是同一层面上的概念
同步是基于互斥的
或者说,同步是由互斥实现的
互斥仅仅只实现了<font color=#F09B59 style=" font-weight:bold;">排他性</font>
而同步还要解决<font color=#66CC99 style=" font-weight:bold;">顺序</font>的问题,谁在前,谁在后
也就是说我们要<font color=#FF6666* style=" font-weight:bold;">在实现了互斥的基础上还要解决异步性才能实现同步</font>


##### 共享资源
进程的并发肯定会遇到多个进程获取同一个资源的问题
这个资源叫做共享资源

这个共享资源包括两种截然不同的共享方式
* 互斥共享
* 同时共享

##### 互斥共享
虽然这个资源可以给多个进程共享获取
但<font color=#66CC99 style=" font-weight:bold;">一个时间段内只能一个进程访问该资源</font>
采用互斥共享方式的资源就是<font color=#66CC99 style=" font-weight:bold;">临界资源</font>
[临界资源](第二章_进程与线程#####什么是临界资源?)

##### 同时共享
一个时间段内多个进程都可以对该资源获取访问

##### 设计进程互斥的原则
1．空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;
2．忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;
3．有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿)
4．让权等待。当进程<font color=#66CC99 style=" font-weight:bold;">不能进入临界区时，应立即释放处理机，防止进程忙等待</font>。

![](img/Pasted%20image%2020220921171431.png)

### 进程互斥的实现
#### 软件层面实现
* 单标志
* 双标志
* 双标志后检查
* Peterson算法
根据<font color=#99CCFF style=" font-weight:bold;">蒋炎岩的操作系统课</font>上的三种软件层面实现互斥的算法
其局限太大
即使是最厉害的Peterson算法利用复杂的逻辑判断也<font color=#66CC99 style=" font-weight:bold;">只能实现两个进程的互斥</font>
因为在<font color=#F09B59 style=" font-weight:bold;">多处理器并发状态</font>下
多进程的运行状态是极为<font color=#66CC99 style=" font-weight:bold;">混乱的,基本无法做到同步</font>
用于检测其他进程是否进入临界区的标志位也难以防住
<font color=#66CC99 style=" font-weight:bold;">a进程还没来得及修改标志位,另一个进程就直接进去了</font>


#### 硬件层面实现
* 中断屏蔽
* TSL锁
* swap指令
##### 中断屏蔽
单处理器cpu下可以

中断无法应用域多处理器环境
因为关中断只对关闭中断的那个处理器有用
其他处理器该访问临界区还是能访问
![](img/Pasted%20image%2020220921224737.png)

而且也不适合用户进程使用,因为开关中断都需要切换到内核态才能用,
你一个普通用户进程就能随意使用系统调度相关的中断指令岂不是很危险?

##### TestAndSetLock指令
相比软件实现方法，TSL指令把“上锁”和“检查操作用硬件的方式变成了一气呵成的原子操作
硬件层面实现,所以下面是用c模拟逻辑
```c
//布尔型共享变量lock表示当前临界区是否被加锁
//true表示已加锁，false表示未加锁
bool TestAndSet (bool *lock){
	bool old;
	old = *lock;//old用来存放lock原来的值,用来返回
	*lock = true;//无论之前是否加锁,都将共享变量lock的值设为true
	return old;//返回lock原来的值
}
```
```c
//以下是使用TSL指令实现互斥的算法逻辑
while (TestAndSet(&lock)); //"上锁"并"检查"
临界区代码段...
lock = false;//“解锁"
剩余区代码段...
```
硬件层面上实现的,涉及到总线和寄存器
就不会出现进程层面的异步混乱问题

缺点:不满足“让权等待”原则，暂时无法进入临界区的进程会占用cpu并循环执行TSL指令，从而导致“<font color=#66CC99 style=" font-weight:bold;">忙等</font>”

### 锁
##### 互斥锁
对于各程序临界区访问临界资源问题
最简单的解决工具就是互斥锁
互斥锁里有一个available变量,锁被某个进程获取后就改为false
被释放后改为true
<font color=#FFCCCC style=" font-weight:bold;">那么被获取这个行为,以及锁的获取和被释放怎么描述?</font>
那就用一个acquire()函数,当锁被获取时,就调用该函数,将available设为false
available代表锁是否被获取,与释放(release函数)

当一个进程去试图获取一个不可获取的锁(调用acquire),就会<font color=#F09B59 style=" font-weight:bold;">阻塞</font>
<font color=#66CC99 style=" font-weight:bold;">直到该锁被其他进程释放</font>
```java
acquire()
	while(!available)//其他进程想获取锁一直处于忙等待
	available = false;//获得锁
}

release() {
	available = true;//释放锁
}
```
因为这个过程必须是<font color=#66CC99 style=" font-weight:bold;">原子操作</font>,且是硬件层面实现的
[何为原子操作](../../principle_of_computer_organization/王道计组/第六章_总线和io###什么是原子操作)

缺点:
互斥锁在被一个进程进入临界区获取锁后
其他进程只能只能不停循环调用acquire()来获取锁,处于<font color=#66CC99 style=" font-weight:bold;">忙等待</font>状态
(注意:这里的忙等待是一个互斥设计的概念,不要和阻塞搞混了)
因此互斥锁一般用于<font color=#F09B59 style=" font-weight:bold;">多处理器系统</font>
一个处理器每次分时间片给一个忙等待程序执行,很浪费,本来就只有一个核,到你了还啥事不干
多个处理器的话,你让一个闲置的处理器去分配时间片给一直获取锁的进程忙等待也可以接受

##### 自旋锁
需要<font color=#F09B59 style=" font-weight:bold;">连续循环忙等</font>的互斥锁就叫做自旋锁
如果其他进程释放锁快的话,效率就更高

优点:
直接一路忙等下去,一条路走到黑
也不切换进程上下文了,因此对于那些能快速获取到锁,等待代价更低(因为切换别的进程上来)
但随着忙等时间越来越长,开销越来越大

### 信号量
##### 信号量是什么东西呢?
<font color=#F09B59 style=" font-weight:bold;">描述系统中哦共享资源的数量</font>
可以理解为信号量就是资源
因此不同资源要设置不同的信号量
也可以理解为<font color=#66CC99 style=" font-weight:bold;">进入临界区的名额</font>

尝试思考一下,之前软件层面上实现互斥,是很难做到的
比如单标志,双标志,都面临一个问题:
<font color=#66CC99 style=" font-weight:bold;">"检查"和"上锁"这两个操作不能一气呵成的完成</font>,以至于多个进程进入到了<font color=#66CC99 style=" font-weight:bold;">临界区</font>

信号量使用PV原语实现的
[原语是什么](第二章_进程与线程#####原语是什么)

##### PV操作是什么?
pv是荷兰语开头,分别是wait和signal原语
因为wait和signal是原语
p操作:进程想申请资源
v操作:进程想释放资源
所以可以将他们这整个函数视为原子操作
因此解决了之前的"检查"和"上锁"无法一气呵成的缺点

##### 整型信号量
用一个整数型的变量作为信号量，用来表示系统中某种资源的数量.
某计算机系统中有一台打印机
```c
int s = 1;//初始化整型信号量s，表示当前系统中可用的打印机资源数
void wait (int S){// wait原语，相当于”进入区”
	while (S = 0);
	//如果资源数不够，就一直循环等待
	S=S-1;
	//如果资源数够，则占用一个资源
}
void signal (int S) { //signal原语，相当于“退出区”
	S=S+1;
	//使用完资源后，在退出区释放资源
}
```
![](img/Pasted%20image%2020220922225038.png)

因为一个进程获取到了锁后,其他进程只会不停的while循环
会产生<font color=#66CC99 style=" font-weight:bold;">忙等</font>问题,不满足互斥设计的"<font color=#66CC99 style=" font-weight:bold;">让权等</font>待"原则

##### 记录型信号量
<font color=#FFCCCC style=" font-weight:bold;">那如何解决忙等呢?</font>
创建一个阻塞队列
那些本来要陷入while循环的,现在不再循环了,而是加入到阻塞队列
等待被<font color=#66CC99 style=" font-weight:bold;">唤醒</font>
```c
/*记录型信号量的定义*/
typedef struct{
	int value;
	//剩余资源数
	struct process *L;
	//等待队列
}semaphore;

/*某进程需要使用资源时，通过wait原语申请*/
void wait(semaphore S){
	s.value--;
	if (S.value < 0){
		block(S.L);
	}
}
```
block原语
如果剩余资源数不够,使用block原语使进程从运行态进入阻塞态，
并把挂到信号量S的等待队列（即<font color=#F09B59 style=" font-weight:bold;">阻塞队列</font>）中
```c
/*进程使用完资源后，通过signal原语释放*/
void signal(semaphore S){
	S.value++;
	if(S.value <= 0){
		wakeup(S.L);
	}
}		

```
资源被释放后
会调用wakeup原语
从阻塞队列中<font color=#66CC99 style=" font-weight:bold;">唤醒之前被阻塞的进程</font>
重新进入临界区获取资源
![](img/Pasted%20image%2020220922232409.png)

### 信号量实现进程同步
同步是基于互斥的
那么
##### 信号量如何实现进程互斥?
就是上面介绍的两种方式
* 初始化信号量
* 进入区加锁申请资源
* 临界区使用资源
* 退出去释放资源,释放锁
![](img/Pasted%20image%2020220922233439.png)

##### 实现实现同步
思考:
互斥是解决了,但异步性问题仍然存在
那么<font color=#FFCCCC style=" font-weight:bold;">如何保证一前一后呢?</font>
可以围绕着资源来
先设置一个资源,信号量为0
只在对应进程的某一段代码进行V操作释放资源
那么别的进程(p2)在进行P操作获取该资源时就会阻塞(S - 1 < 0)
到轮到p1进程执行到V操作时就会释放资源S+1,
此时S >= 0,同时会唤醒p2进程执行
![](img/Pasted%20image%2020220923004140.png)

前驱关系考题:
![](img/Pasted%20image%2020220923004832.png)