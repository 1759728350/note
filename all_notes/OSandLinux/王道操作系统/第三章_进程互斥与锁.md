### 什么是进程同步?
首先要知道进程异步是什么
##### 进程异步
各个并发进程自顾自的独立运行,不管其他进程的死活,推进运行
并发必然导致异步性(并发必然导致<font color=#F09B59 style=" font-weight:bold;">混乱</font>,混乱到一定程度就不可预测)
异步执行也可以理解为混乱执行
##### 进程同步
确定多个并发进程的先后
比如写进程和读进程
管道通信就必须保证写进程在读进程之前
也就是说<font color=#FF6666* style=" font-weight:bold;">进程同步是为了防止多个并发进程运行混乱,而来协调次序的</font>
![](img/Pasted%20image%2020220921164327.png)

### 进程互斥
进程的并发肯定会遇到多个进程获取同一个资源的问题
这个资源叫做共享资源

这个共享资源包括两种截然不同的共享方式
互斥共享
同时共享

##### 互斥共享
虽然这个资源可以给多个进程共享获取
但一个时间段内只能一个进程访问该资源
采用互斥共享方式的资源就是<font color=#66CC99 style=" font-weight:bold;">临界资源</font>
[临界资源](第二章_进程与线程#####什么是临界资源?)

##### 同时共享
一个时间段内多个进程都可以对该资源获取访问

##### 设计进程互斥的原则
1．空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;
2．忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;
3．有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿)
4．让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

![](img/Pasted%20image%2020220921171431.png)

### 进程互斥的实现
#### 软件层面实现
* 单标志
* 双标志
* 双标志后检查
* Peterson算法
根据<font color=#99CCFF style=" font-weight:bold;">蒋炎岩的操作系统课</font>上的三种软件层面实现互斥的算法
其局限太大
即使是最厉害的Peterson算法利用复杂的逻辑判断也<font color=#66CC99 style=" font-weight:bold;">只能实现两个进程的互斥</font>
因为在多处理器并发状态下
多进程的运行状态是极为混乱的,基本无法做到同步
用于检测其他进程是否进入临界区的标志位也难以防住
a进程还没来得及修改标志位,另一个进程就直接进去了


#### 硬件层面实现
* 中断屏蔽
* TSL锁
* swap指令
##### 中断屏蔽
单处理器cpu下可以

中断无法应用域多处理器环境
因为关中断只对关闭中断的那个处理器有用
其他处理器该访问临界区还是能访问
![](img/Pasted%20image%2020220921224737.png)

而且也不适合用户进程使用,因为开关中断都需要切换到内核态才能用,
你一个普通用户进程就能随意使用系统调度相关的中断指令岂不是很危险?

##### TestAndSetLock指令
相比软件实现方法，TSL指令把“上锁”和“检查操作用硬件的方式变成了一气呵成的原子操作
硬件层面实现,所以下面是用c模拟逻辑
```c
//布尔型共享变量lock表示当前临界区是否被加锁
//true表示已加锁，false表示未加锁
bool TestAndSet (bool *lock){
	bool old;
	old = *lock;//old用来存放lock原来的值,用来返回
	*lock = true;//无论之前是否加锁,都将共享变量lock的值设为true
	return old;//返回lock原来的值
}
```
```c
//以下是使用TSL指令实现互斥的算法逻辑
while (TestAndSet(&lock)); //"上锁"并"检查"
临界区代码段...
lock = false;//“解锁"
剩余区代码段...
```
硬件层面上实现的,涉及到总线和寄存器
就不会出现进程层面的异步混乱问题

缺点:不满足“让权等待”原则，暂时无法进入临界区的进程会占用cpu并循环执行TSL指令，从而导致“<font color=#66CC99 style=" font-weight:bold;">忙等</font>”

### 锁
##### 互斥锁
对于各程序临界区访问临界资源问题
最简单的解决工具就是互斥锁
互斥锁里有一个available变量,锁被某个进程获取后就改为false
被释放后改为true
当一个进程去试图获取一个不可获取的锁,就会<font color=#F09B59 style=" font-weight:bold;">阻塞</font>
<font color=#66CC99 style=" font-weight:bold;">直到该锁被其他进程释放</font>
```java
acquire()
	while(!available)//其他进程想获取锁一直处于忙等待
	available = false;//获得锁
}

release() {
	available = true;//释放锁
}
```
因为这个过程必须是<font color=#66CC99 style=" font-weight:bold;">原子操作</font>,且是硬件层面实现的
[何为原子操作](../../principle_of_computer_organization/王道计组/第六章_总线和io###什么是原子操作)

缺点:
互斥锁在被一个进程进入临界区获取锁后
其他进程只能只能不停循环调用acquire()来获取锁,处于<font color=#66CC99 style=" font-weight:bold;">忙等待</font>状态
(注意:这里的忙等待是一个互斥设计的概念,不要和阻塞搞混了)
因此互斥锁一般用于<font color=#F09B59 style=" font-weight:bold;">多处理器系统</font>
一个处理器每次分时间片给一个忙等待程序执行,很浪费,本来就只有一个核,到你了还啥事不干
多个处理器的话,你让一个闲置的处理器去分配时间片给一直获取锁的进程忙等待也可以接受

##### 自旋锁
需要<font color=#F09B59 style=" font-weight:bold;">连续循环忙等</font>的互斥锁就叫做自旋锁

优点:
直接一路忙等下去,一条路走到黑
也不切换进程上下文了,因此对于那些能快速获取到锁,等待代价更低(因为切换别的进程上来)
