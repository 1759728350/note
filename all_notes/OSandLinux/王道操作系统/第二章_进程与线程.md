### pcb是什么
PCB：process ctrl block（进程控制块）
在操作系统代码当中是一个结构体：struct task_struct{...}
用以描述进程信息
![](img/Pasted%20image%2020220915201535.png)

pcb还会存储进程的运行环境信息
时间片执行完后切换别的进程,原有的pc寄存器会被覆盖
下一次切换回来你都不知道执行到哪一步了
运算到一半的数据保存在通用寄存器里的也被覆盖了
你pc指针难道还要移到入口重新算一遍?
所以最佳的策略还是将其保存到对应进程的pcb中

### 进程的组成
<font color=#66CC99 style=" font-weight:bold;">进程是运行起来的程序</font>,是动态的,是<font color=#F09B59 style=" font-weight:bold;">过程/状态的实体</font>
因此,每一时刻状态都有可能不同,就如同吃鸡游戏里的每一玩家一样
PCB记录玩家的得分,坐标等状态,操作系统由pcb能获取到玩家(进程)状态
程序段和数据段就是程序本身
![](img/Pasted%20image%2020220915202331.png)

同时挂三个QQ号，会对应三个QQ进程,它们的<font color=#66CC99 style=" font-weight:bold;">PCB、数据段各不相同</font>，但<font color=#66CC99 style=" font-weight:bold;">程序段的内容都是相同的</font>(都是运行着相同的QQ程序)

### 进程的状态
进程状态的切换围绕着<font color=#66CC99 style=" font-weight:bold;">资源会否到位,以及cpu时间片的分配</font>
也就是说围绕着硬件来的
毕竟cpu的个数有限,打印机也只有一个,数据总线也就怎么多条,且要花很长时间才能读写
所以进程的状态描述的就是
进程怎么<font color=#66CC99 style=" font-weight:bold;">利用系统资源</font>(<font color=#F09B59 style=" font-weight:bold;">系统将硬件资源抽象化/虚拟化</font>),先来后到?怎样利用更加高效?
![](img/Pasted%20image%2020220915215122.png)
何为系统调用?
[第一章_操作系统概述/系统调用](第一章_操作系统概述###系统调用)
简化版
![](img/Pasted%20image%2020220915223136.png)
* 创建态
进程正在被创建时，它的状态是“创建态”，
在这个阶段操作系统会为进程分配资源、初始化PCB
* 就绪态
当进程创建完成后，便进入“就绪态”
处于就绪态的进程已经具备运行条件，
但由手没有空闲CPU，就暂时不能运行
* 运行态
如果些个进程此时在CPU上运行，那么这个进程处于“运行态”。
CPU会执行该进程对应的程序（执行指令序列)
<font color=#66CC99 style=" font-weight:bold;">时间片执行完后又会进入就绪态</font>
* 阻塞态
在进程运行的过程中可能会请求等待某个事件的发生
（如<font color=#66CC99 style=" font-weight:bold;">等待某种系统资源的分配,io请求或者等待其他进程的响应</font>）
在这个事件发生之前进程无法继续往下执行，
此时操作系统会让这个进程下CPU，
并让它进入“阻塞态”
当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行
此时进程还在内存中
<font color=#99CCFF style=" font-weight:bold;">和挂起是不同的</font>
我想应该会有一个全局轮询检查阻塞状态进程所需资源是否已获取的进程
若以获取,将其转换为就绪态
* 终止态
一个进程可以执行<font color=#66CC99 style=" font-weight:bold;">exit</font>系统调用工请求操作系统终止该进程。
此时该进程会进入“终止态”操作系统会让该进程下CPU,
并回收内存空间等资源最后还要回收该进程的PCB。
当终止进程的工作完成之后，这个进程就彻底消失了。

![](img/Pasted%20image%2020220915215431.png)

##### 进程的组织
利用<font color=#66CC99 style=" font-weight:bold;">队列存储</font>不同类型的进程的pcb
轮训时到对应的队列执行/激活进程
![](img/Pasted%20image%2020220915215524.png)

### 进程状态转变是如何实现的?
利用原语
原语就是利用开/关中断实现的
[中断是什么](第一章_操作系统概述###中断)
[什么是原子操作](../../principle_of_computer_organization/王道计组/第六章_总线和io###什么是原子操作)
原语执行时关中断,中断一关,当前程序一定会执行完才会去执行其他程序
达到原子操作,一气呵成的执行完整个状态转变的过程

<font color=#99CCFF style=" font-weight:bold;">具体实现等以后看linux和unix源码后再去思考吧</font>
![](img/Pasted%20image%2020220921001448.png)
![](img/Pasted%20image%2020220921001529.png)


<font color=#99CCFF style=" font-weight:bold;">上面的不会没关系以后看源码再去思考吧</font>

### 进程通信
##### 共享存储
<font color=#99CCFF style=" font-weight:bold;">开一块内存作为共享内存进行数据传递(虚拟内存章节会学)</font>
多个进程对于<font color=#99CCFF style=" font-weight:bold;">共享内存的读写会产生读者/写者问题</font>后面学习
此时就需要<font color=#66CC99 style=" font-weight:bold;">系统已经实现的同步互斥工具</font>(互斥从代码上特别难实现,不过系统为我们提供了实现)

不过你随意开的共享存储区的写入和读取都要有规则
即<font color=#66CC99 style=" font-weight:bold;">数据结构要有规则</font>,写在哪个地方也要有规则
比如就是一个数组,数组长为5,每次只写入int类型的数
数据得方便获取,不然另一个进程难以读取
![](img/Pasted%20image%2020220916035408.png)


##### 消息传递
* 直接通信
切换到系统内核在pcb里建立一个消息队列
![](img/Pasted%20image%2020220916180129.png)

间接通信
理解不明白
![](img/Pasted%20image%2020220916180421.png)

##### 管道通信
管道通信面临的是进程协状态管理和<font color=#99CCFF style=" font-weight:bold;">多进程读写问题</font>
![](img/Pasted%20image%2020220916184437.png)
1．管道只能采用半双工通信，某一时间段内只能实现单向的传输。
如果要实现双向同时通信，则需要设置两个管道。
2. 各进程要互斥地访问管道（由操作系统实现)
3．<font color=#66CC99 style=" font-weight:bold;">当管道写满时，写进程将阻塞</font>，
  直到读进程将管道中的数据取走，即可唤醒写进程。
4．<font color=#66CC99 style=" font-weight:bold;">当管道读空时，读进程将阻塞</font>，
直到写进程往管道中写入数据，即可唤醒读进程。
5．管道中的数据<font color=#66CC99 style=" font-weight:bold;">一旦被读出，就彻底消失</font>。
因此，当多个进程读同一个管道时，可能会错乱。
对此，通常有两种解决方案:
①一个管道允许多个写进程，一个读进程(2014年408真题高教社官方答案)﹔
②允许有多个写进程，多个读进程，
但系统会让各个读进程轮流从管道中读数据（Linux的方案）。

### 线程
#####  为什么要引用线程
有的进程可能需要“同时”做很多事，
而传统的进程只能<font color=#66CC99 style=" font-weight:bold;">串行</font>地执行一系列程序。
你想一下,传统的进程不就是一段代码吗?
从上一路运行到下
一个程序我们需要并行/并发的运行许多功能
为此，引入了“线程”，来增加并发度。

![](img/Pasted%20image%2020220916182638.png)

进程是程序的一次执行但
<font color=#66CC99 style=" font-weight:bold;">这些功能显然不可能是由个程序顺序处理就能实现的</font>
所以需要引入线程概念

##### 什么是线程
在线程出现以后,cpu调度的基本单位就不再是进程而是线程了
进程是资源分配的基本单位
<font color=#F09B59 style=" font-weight:bold;">一个进程内的线程共享系统资源</font>

进程内的线程切换将不再需要切换进程运行环境
一个进程内的线程切换所耗费的系统开销要<font color=#F09B59 style=" font-weight:bold;">小于多个进程切换的开销</font>

引入线程概念后,进程内部的<font color=#F09B59 style=" font-weight:bold;">并发</font>性提高了
![](img/Pasted%20image%2020220916183751.png)


### 线程的实现
早期的傻瓜式实现多线程
![](img/Pasted%20image%2020220920015010.png)

可以看得出来,早期的线程仅仅只是分支逻辑的体现
一个线程的堵塞会影响其他线程
#### 什么是用户级线程?
用户级线程就是只需要在用户态下就能实现线程调度
不需要操作系统干预,也干预不了,毕竟没有涉及到中断切换内核态

* 用户级线程由应用程序通过<font color=#66CC99 style=" font-weight:bold;">线程库实现</font>，所有的线程管理工作都由应用程序负责（包括线程切换)
* 用户级线程中，线程切换可以在用户态下即可完成，<font color=#66CC99 style=" font-weight:bold;">无需操作系统干预</font>。
* 在用户看来，是有多个线程。但是在操作系统内核看来，并<font color=#F09B59 style=" font-weight:bold;">意识不到</font>线程的存在。“用户级线程”就是“从用户视角看能看到的线程”

#### 什么是内核级线程?
* 内核级线程的管理工作由操作系统内核完成。
* 线程调度、切换等工作都由内核负责，因此<font color=#66CC99 style=" font-weight:bold;">内核级线程的切换必然需要在核心态下才能完成</font>。
* 操作系统会为每个内核级线程建立相应的TCB ( Thread Control Block，线程控制块)，通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”

##### 一对一内核级线程
![](img/Pasted%20image%2020220920022902.png)

##### 优缺点
* 优点:当一个<font color=#F09B59 style=" font-weight:bold;">线程被阻塞</font>后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
* 缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

因此引入多对多内核级线程
##### 多对多内核级线程
多对多模型: n用户及线程映射到m个内核级线程(n >= m)。每个用户进程对应m个内核级线程。
模型如下:

##### 多线程模型
![](img/Pasted%20image%2020220920024120.png)

克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞)，
又克服了一对一模型中一个用户进程占用太多内核级线程开销太大的缺点。

可以这么理解:
<font color=#66CC99 style=" font-weight:bold;">用户级线程是“代码逻辑”的载体</font>
<font color=#66CC99 style=" font-weight:bold;">内核级线程是“运行机会”的载体</font>
<font color=#66CC99 style=" font-weight:bold;">内核级线程才是处理机分配的单位。例如:多核CPU环境下，左边这个进程最多能被分配两个核。</font>

一段“代码逻辑”只有获得了“运行机会”才能被CPU执行
内核级线程中可以运行任意一个有映射关系的用户级线程代码，<font color=#66CC99 style=" font-weight:bold;">只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞</font>

### 线程的状态转换
和进程原理一样
区别于进程的pcb,线程是tcb来抽象每个线程
![](img/Pasted%20image%2020220920024540.png)


### 调度的层次
![](img/Pasted%20image%2020220920161759.png)


#### 作业调度
<font color=#FFCCCC style=" font-weight:bold;">为什么要进行作业调度?</font>
![](img/Pasted%20image%2020220920160159.png)
内存空间有限，有时无法将用户提交的作业全部放入内存
好几个程序需要启动,先<font color=#66CC99 style=" font-weight:bold;">启动</font>哪一个
作业调度就是理解为<font color=#66CC99 style=" font-weight:bold;">启动调度</font>
![](img/Pasted%20image%2020220920160141.png)

#### 进程调度
<font color=#FF6666* style=" font-weight:bold;">按照某种策略从就绪队列中选取一个进程，将处理机分配 给它</font>

![](img/Pasted%20image%2020220920160735.png)
进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。 进程调度的频率很高，一般几十毫秒一次。




#### 内存调度
内存不够时，可将某些<font color=#66CC99 style=" font-weight:bold;">进程</font>的数据<font color=#66CC99 style=" font-weight:bold;">调出外存</font>。等内存空闲或者进程需要运行时再重新调入内存。 暂时调到外存等待的进程状态为<font color=#F09B59 style=" font-weight:bold;">挂起状态</font>。被挂起的进程PCB会被组织成挂起队列
![](img/Pasted%20image%2020220920160942.png)

按照某种策略决定将哪个处于挂起状态的进程重新调入内存。 
一个进程可能会被多次调出、调入内存，
因此中级调度发生的频率要比高级调度更高。

### 挂起和七状态模型
暂时调到外存等待的进程状态为挂起状态（挂起态，suspend） 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态
![](img/Pasted%20image%2020220920161518.png)

##### 挂起和阻塞的区别
进程挂起后方外存去了
阻塞还是在内存里


### 进程调度详解
#### 进程切换包括
选择一个新的进程
对原来的进程的运行数据进行保存
对新来的进程进行数据恢复

#### 需要当前进程切换的情况
##### 当前进程主动放弃cpu
进程正常终止(内中断)
运行过程中发现异常而终止(内中断)
进程主动请求阻塞,等待io(内中断)

##### 当前进程被动放弃cpu
分给进程的时间片用完 (外部中断)
有更紧急的事需要处理,如I/O中断 (外部中断)
有更高优先级的进程进入就绪队列(阻塞后被唤醒进入就绪队列)


[内中断和外中断](第一章_操作系统概述#####外中断)

#### 当前进程不能进行进程切换的情况
1. 在处理中断的过程中 (注意是过程中,不是中断后) 中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。
2. 进程在<font color=#99CCFF style=" font-weight:bold;">操作系统内核程序临界区</font>中。(但是进程在普通临界区中是可以讲行调度、切换的)
3. 在原子操作过程中(原语),原子操作不可中断，要一气呵成（如
之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列)

第二点补充
##### 什么是临界资源?
一个时间段内只允许一个进程使用的资源,
各进程需要互斥地访问临界资源
##### 什么是临界区?
每个进程中访问临界资源的那段代码
是系统提供的一种数据结构，程序中可以声明一个该类型的变量，
之后用它来实现对资源的互斥访问。
当欲访问某一临界资源时，<font color=#F09B59 style=" font-weight:bold;">先将该临界区加锁</font>（若临界区不空闲则等待），
不允许其他进程进入
用完该资源后，将临界区释放。

##### 为什么在操作系统内核程序临界区中不能进行调度与切换?
内核程序临界区一般是用来访问某种内核数据结构的内核程序的代码，
比如进程的就绪队列就是内核数据结构（由各就绪进程的PCB组成）
![](img/Pasted%20image%2020220920193211.png)
<font color=#66CC99 style=" font-weight:bold;">内核程序临界区访问的临界资源如果不尽快释放的话</font>，
极有可能<font color=#66CC99 style=" font-weight:bold;">影响到操作系统内核的其他管理工作</font>
因此在访问内核程序临界区期间不能进行调度与切换
<font color=#66CC99 style=" font-weight:bold;">把进程的就绪队列都给锁了,其他进程调度的内核程序访问不了当然就切换不了其他进程了</font>

##### 为什么普通临界区中能进行调度与切换?
![](img/Pasted%20image%2020220920193725.png)
普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。
因此在访问普通临界区时可以进行调度与切换。



 #### 剥夺和非剥夺调度 
 剥夺调度方式是分时操作系统的基础
![](img/Pasted%20image%2020220920181854.png)

### 调度时机
什么时候会触发调度程序?

* 创建新进程
* 进程退出运行
* 进程阻塞
* io中断发生（可能<font color=#F09B59 style=" font-weight:bold;">唤醒某些阻塞进程,将其加入到就绪队列</font>)

抢占式调度策略，每个<font color=#F09B59 style=" font-weight:bold;">时钟中断</font>或k个时钟 中断会<font color=#66CC99 style=" font-weight:bold;">触发调度程序</font>工作
现代操作系统主要是抢占式(分时操作系统)
![](img/Pasted%20image%2020220920233308.png)

调度程序决定:
让谁运行？       ——调度算法 
运行多长时间？——时间片大小

### 调度算法和性能
* 先来先服务（FCFS, First Come First Serve）
* 短作业优先（SJF, Shortest Job First）
* 高响应比优先（HRRN, Highest Response Ratio Next）
##### 高响应比优先
综合考虑了等待时间和运行时间（要求服务时间） 等待时间相同时，
要求服务时间短的优先（SJF 的优点） 要求服务时间相同时，等待时间长的优先（FCFS 的优点） 对于长作业来说，
随着等待时间越来越久，其响应比也会 越来越大，从而避免了长作业饥饿的问题
![](img/Pasted%20image%2020220920234653.png)


##### 时间片轮转
* 时间片轮转（RR, Round-Robin）
公平地、轮流地为各个进程服务，让每个进程在一定时间 间隔内都可以得到响应
按照各进程到达就绪队列的顺序，轮流让各个进程执行一 个时间片（如 100ms）。若进程未在一个时间片内执行完， 则剥夺处理机，将进程重新放到就绪队列队尾重新排队。

##### 优先级调度算法
随着计算机的发展，特别是实时操作系统的出现，越来越 多的应用场景需要根据任务的紧急程度来决定处理顺序
每个作业/进程有各自的优先级，调度时选择优先级最高的 作业/进程
![](img/Pasted%20image%2020220920235648.png)


![](img/Pasted%20image%2020220920235735.png)

##### 多级反馈队列调度算法
对各类型进程相对公平（FCFS的优点）
每个新到达的进程都可以 很快就得到响应（RR的优点）
短进程只用较少的时间就可完成 （SPF的优点）
不必实现估计进程的运行时间（避免用户作假）
可灵活地调整对各类进程的偏好程度，
比如CPU密集型进程、I/O密 集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样 I/O型进程就可以保持较高优先级）
![](img/Pasted%20image%2020220921000424.png)

先到的会更先执行
短作业可以更优先执行
长作业可以每次获得的时间片更多,获得更多执行时间