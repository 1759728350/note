### pcb是什么
PCB：process ctrl block（进程控制块）
在操作系统代码当中是一个结构体：struct task_struct{...}
用以描述进程信息
![](img/Pasted%20image%2020220915201535.png)

### 进程的组成
<font color=#66CC99 style=" font-weight:bold;">进程是运行起来的程序</font>,是动态的,是<font color=#F09B59 style=" font-weight:bold;">过程/状态的实体</font>
因此,每一时刻状态都有可能不同,就如同吃鸡游戏里的每一玩家一样
PCB记录玩家的得分,坐标等状态,操作系统由pcb能获取到玩家(进程)状态
程序段和数据段就是程序本身
![](img/Pasted%20image%2020220915202331.png)

同时挂三个QQ号，会对应三个QQ进程,它们的<font color=#66CC99 style=" font-weight:bold;">PCB、数据段各不相同</font>，但<font color=#66CC99 style=" font-weight:bold;">程序段的内容都是相同的</font>(都是运行着相同的QQ程序)

### 进程的状态
进程状态的切换围绕着<font color=#66CC99 style=" font-weight:bold;">资源会否到位,以及cpu时间片的分配</font>
也就是说围绕着硬件来的
毕竟cpu的个数有限,打印机也只有一个,数据总线也就怎么多条,且要花很长时间才能读写
所以进程的状态描述的就是
进程怎么<font color=#66CC99 style=" font-weight:bold;">利用系统资源</font>(<font color=#F09B59 style=" font-weight:bold;">系统将硬件资源抽象化/虚拟化</font>),先来后到?怎样利用更加高效?
![](img/Pasted%20image%2020220915215122.png)
何为系统调用?
[第一章_操作系统概述/系统调用](第一章_操作系统概述###系统调用)
简化版
![](img/Pasted%20image%2020220915223136.png)
* 创建态
进程正在被创建时，它的状态是“创建态”，
在这个阶段操作系统会为进程分配资源、初始化PCB
* 就绪态
当进程创建完成后，便进入“就绪态”
处于就绪态的进程已经具备运行条件，
但由手没有空闲CPU，就暂时不能运行
* 运行态
如果些个进程此时在CPU上运行，那么这个进程处于“运行态”。
CPU会执行该进程对应的程序（执行指令序列)
<font color=#66CC99 style=" font-weight:bold;">时间片执行完后又会进入就绪态</font>
* 阻塞态
在进程运行的过程中可能会请求等待某个事件的发生
（如<font color=#66CC99 style=" font-weight:bold;">等待某种系统资源的分配,io请求或者等待其他进程的响应</font>）
在这个事件发生之前进程无法继续往下执行，
此时操作系统会让这个进程下CPU，
并让它进入“阻塞态”
当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行
此时进程还在内存中
<font color=#99CCFF style=" font-weight:bold;">和挂起是不同的</font>
我想应该会有一个全局轮询检查阻塞状态进程所需资源是否已获取的进程
若以获取,将其转换为就绪态
* 终止态
一个进程可以执行<font color=#66CC99 style=" font-weight:bold;">exit</font>系统调用工请求操作系统终止该进程。
此时该进程会进入“终止态”操作系统会让该进程下CPU,
并回收内存空间等资源最后还要回收该进程的PCB。
当终止进程的工作完成之后，这个进程就彻底消失了。

![](img/Pasted%20image%2020220915215431.png)

##### 进程的组织
利用<font color=#66CC99 style=" font-weight:bold;">队列存储</font>不同类型的进程的pcb
轮训时到对应的队列执行/激活进程
![](img/Pasted%20image%2020220915215524.png)