### pcb是什么
PCB：process ctrl block（进程控制块）
在操作系统代码当中是一个结构体：struct task_struct{...}
用以描述进程信息
![](img/Pasted%20image%2020220915201535.png)

pcb还会存储进程的运行环境信息
时间片执行完后切换别的进程,原有的pc寄存器会被覆盖
下一次切换回来你都不知道执行到哪一步了
运算到一半的数据保存在通用寄存器里的也被覆盖了
你pc指针难道还要移到入口重新算一遍?
所以最佳的策略还是将其保存到对应进程的pcb中

### 进程的组成
<font color=#66CC99 style=" font-weight:bold;">进程是运行起来的程序</font>,是动态的,是<font color=#F09B59 style=" font-weight:bold;">过程/状态的实体</font>
因此,每一时刻状态都有可能不同,就如同吃鸡游戏里的每一玩家一样
PCB记录玩家的得分,坐标等状态,操作系统由pcb能获取到玩家(进程)状态
程序段和数据段就是程序本身
![](img/Pasted%20image%2020220915202331.png)

同时挂三个QQ号，会对应三个QQ进程,它们的<font color=#66CC99 style=" font-weight:bold;">PCB、数据段各不相同</font>，但<font color=#66CC99 style=" font-weight:bold;">程序段的内容都是相同的</font>(都是运行着相同的QQ程序)

### 进程的状态
进程状态的切换围绕着<font color=#66CC99 style=" font-weight:bold;">资源会否到位,以及cpu时间片的分配</font>
也就是说围绕着硬件来的
毕竟cpu的个数有限,打印机也只有一个,数据总线也就怎么多条,且要花很长时间才能读写
所以进程的状态描述的就是
进程怎么<font color=#66CC99 style=" font-weight:bold;">利用系统资源</font>(<font color=#F09B59 style=" font-weight:bold;">系统将硬件资源抽象化/虚拟化</font>),先来后到?怎样利用更加高效?
![](img/Pasted%20image%2020220915215122.png)
何为系统调用?
[第一章_操作系统概述/系统调用](第一章_操作系统概述###系统调用)
简化版
![](img/Pasted%20image%2020220915223136.png)
* 创建态
进程正在被创建时，它的状态是“创建态”，
在这个阶段操作系统会为进程分配资源、初始化PCB
* 就绪态
当进程创建完成后，便进入“就绪态”
处于就绪态的进程已经具备运行条件，
但由手没有空闲CPU，就暂时不能运行
* 运行态
如果些个进程此时在CPU上运行，那么这个进程处于“运行态”。
CPU会执行该进程对应的程序（执行指令序列)
<font color=#66CC99 style=" font-weight:bold;">时间片执行完后又会进入就绪态</font>
* 阻塞态
在进程运行的过程中可能会请求等待某个事件的发生
（如<font color=#66CC99 style=" font-weight:bold;">等待某种系统资源的分配,io请求或者等待其他进程的响应</font>）
在这个事件发生之前进程无法继续往下执行，
此时操作系统会让这个进程下CPU，
并让它进入“阻塞态”
当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行
此时进程还在内存中
<font color=#99CCFF style=" font-weight:bold;">和挂起是不同的</font>
我想应该会有一个全局轮询检查阻塞状态进程所需资源是否已获取的进程
若以获取,将其转换为就绪态
* 终止态
一个进程可以执行<font color=#66CC99 style=" font-weight:bold;">exit</font>系统调用工请求操作系统终止该进程。
此时该进程会进入“终止态”操作系统会让该进程下CPU,
并回收内存空间等资源最后还要回收该进程的PCB。
当终止进程的工作完成之后，这个进程就彻底消失了。

![](img/Pasted%20image%2020220915215431.png)

##### 进程的组织
利用<font color=#66CC99 style=" font-weight:bold;">队列存储</font>不同类型的进程的pcb
轮训时到对应的队列执行/激活进程
![](img/Pasted%20image%2020220915215524.png)

### 进程状态转变是如何实现的?
利用原语
原语就是利用开/关中断实现的
[中断是什么](第一章_操作系统概述###中断)
[什么是原子操作](../../principle_of_computer_organization/王道计组/第六章_总线和io###什么是原子操作)
原语执行时关中断,中断一关,当前程序一定会执行完才会去执行其他程序
达到原子操作,一气呵成的执行完整个状态转变的过程

<font color=#99CCFF style=" font-weight:bold;">具体实现等以后看linux和unix源码后再去思考吧</font>
进程创建
![](img/Pasted%20image%2020220916032328.png)
进程终止
![](img/Pasted%20image%2020220916032359.png)
进程阻塞
![](img/Pasted%20image%2020220916032430.png)
进程切换
![](img/Pasted%20image%2020220916032554.png)

<font color=#99CCFF style=" font-weight:bold;">上面的不会没关系以后看源码再去思考吧</font>

### 进程通信
##### 共享存储
<font color=#99CCFF style=" font-weight:bold;">开一块内存作为共享内存进行数据传递(虚拟内存章节会学)</font>
多个进程对于<font color=#99CCFF style=" font-weight:bold;">共享内存的读写会产生读者/写者问题</font>后面学习
此时就需要<font color=#66CC99 style=" font-weight:bold;">系统已经实现的同步互斥工具</font>(互斥从代码上特别难实现,不过系统为我们提供了实现)

不过你随意开的共享存储区的写入和读取都要有规则
即<font color=#66CC99 style=" font-weight:bold;">数据结构要有规则</font>,写在哪个地方也要有规则
比如就是一个数组,数组长为5,每次只写入int类型的数
数据得方便获取,不然另一个进程难以读取
![](img/Pasted%20image%2020220916035408.png)


##### 消息传递
* 直接通信
切换到系统内核在pcb里建立一个消息队列
![](img/Pasted%20image%2020220916180129.png)

间接通信
理解不明白
![](img/Pasted%20image%2020220916180421.png)

##### 管道通信
管道通信面临的是进程协状态管理和<font color=#99CCFF style=" font-weight:bold;">多进程读写问题</font>
![](img/Pasted%20image%2020220916184437.png)
1．管道只能采用半双工通信，某一时间段内只能实现单向的传输。
如果要实现双向同时通信，则需要设置两个管道。
2. 各进程要互斥地访问管道（由操作系统实现)
3．<font color=#66CC99 style=" font-weight:bold;">当管道写满时，写进程将阻塞</font>，
  直到读进程将管道中的数据取走，即可唤醒写进程。
4．<font color=#66CC99 style=" font-weight:bold;">当管道读空时，读进程将阻塞</font>，
直到写进程往管道中写入数据，即可唤醒读进程。
5．管道中的数据<font color=#66CC99 style=" font-weight:bold;">一旦被读出，就彻底消失</font>。
因此，当多个进程读同一个管道时，可能会错乱。
对此，通常有两种解决方案:
①一个管道允许多个写进程，一个读进程(2014年408真题高教社官方答案)﹔
②允许有多个写进程，多个读进程，
但系统会让各个读进程轮流从管道中读数据（Linux的方案）。

### 线程
#####  为什么要引用线程
有的进程可能需要“同时”做很多事，
而传统的进程只能<font color=#66CC99 style=" font-weight:bold;">串行</font>地执行一系列程序。
你想一下,传统的进程不就是一段代码吗?
从上一路运行到下
一个程序我们需要并行/并发的运行许多功能
为此，引入了“线程”，来增加并发度。

![](img/Pasted%20image%2020220916182638.png)

进程是程序的一次执行但
<font color=#66CC99 style=" font-weight:bold;">这些功能显然不可能是由个程序顺序处理就能实现的</font>
所以需要引入线程概念

##### 什么是线程
在线程出现以后,cpu调度的基本单位就不再是进程而是线程了
进程是资源分配的基本单位
<font color=#F09B59 style=" font-weight:bold;">一个进程内的线程共享系统资源</font>

进程内的线程切换将不再需要切换进程运行环境
一个进程内的线程切换所耗费的系统开销要<font color=#F09B59 style=" font-weight:bold;">小于多个进程切换的开销</font>

引入线程概念后,进程内部的<font color=#F09B59 style=" font-weight:bold;">并发</font>性提高了
![](img/Pasted%20image%2020220916183751.png)


### 线程的实现
早期的傻瓜式实现多线程
![](img/Pasted%20image%2020220920015010.png)

可以看得出来,早期的线程仅仅只是分支逻辑的体现
一个线程的堵塞会影响其他线程
#### 什么是用户级线程?
用户级线程就是只需要在用户态下就能实现线程调度
不需要操作系统干预,也干预不了,毕竟没有涉及到中断切换内核态

* 用户级线程由应用程序通过<font color=#66CC99 style=" font-weight:bold;">线程库实现</font>，所有的线程管理工作都由应用程序负责（包括线程切换)
* 用户级线程中，线程切换可以在用户态下即可完成，<font color=#66CC99 style=" font-weight:bold;">无需操作系统干预</font>。
* 在用户看来，是有多个线程。但是在操作系统内核看来，并<font color=#F09B59 style=" font-weight:bold;">意识不到</font>线程的存在。“用户级线程”就是“从用户视角看能看到的线程”

#### 什么是内核级线程?
* 内核级线程的管理工作由操作系统内核完成。
* 线程调度、切换等工作都由内核负责，因此<font color=#66CC99 style=" font-weight:bold;">内核级线程的切换必然需要在核心态下才能完成</font>。
* 操作系统会为每个内核级线程建立相应的TCB ( Thread Control Block，线程控制块)，通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”

##### 一对一内核级线程
![](img/Pasted%20image%2020220920022902.png)

##### 优缺点
* 优点:当一个<font color=#F09B59 style=" font-weight:bold;">线程被阻塞</font>后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
* 缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

因此引入多对多内核级线程
##### 多对多内核级线程
多对多模型: n用户及线程映射到m个内核级线程(n >= m)。每个用户进程对应m个内核级线程。

多线程模型
![](img/Pasted%20image%2020220920024120.png)

克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞)，
又克服了一对一模型中一个用户进程占用太多内核级线程开销太大的缺点。

可以这么理解:
<font color=#66CC99 style=" font-weight:bold;">用户级线程是“代码逻辑”的载体</font>
<font color=#66CC99 style=" font-weight:bold;">内核级线程是“运行机会”的载体</font>
<font color=#66CC99 style=" font-weight:bold;">内核级线程才是处理机分配的单位。例如:多核CPU环境下，左边这个进程最多能被分配两个核。</font>

一段“代码逻辑”只有获得了“运行机会”才能被CPU执行
内核级线程中可以运行任意一个有映射关系的用户级线程代码，<font color=#66CC99 style=" font-weight:bold;">只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞</font>

### 线程的状态转换
和进程原理一样
区别于进程的pcb,线程是tcb来抽象每个线程
![](img/Pasted%20image%2020220920024540.png)