##### 常见的字符编码方式
ASCII
7bit表示 2^7=128种字符
非英语国家不够用
一个字符占一个字节

ISO
8bit一个字符,表示256种字符
非英语国家不够用
一个字符占一个字节

gb2312
部分汉字
两个字节表示一个字符

gbk/gb180303
所有汉字
两个字节表示一个字符

Unicode
这是一个字符集,不是编码方式

utf-8
变长字节表示字符
用(1~6)个字节表示一个字符
<font color=#F09B59 style=" font-weight:bold;">英文用一个字节,中文用三个字节表示一个字符</font>
windows系统下由utf-8编码的文件创建后,起始位置会有一个BOM标记
(如何标明一个文件是utf8格式呢？用windows自带的记事本创建一个utf8格式的文件，就会加上这个标记。但是，如果用ultraedit创建utf8文件，并不会加上这个标记。这个标记有个术语，叫做BOM（Byte Order Mark）。不带BOM的utf8文件和GB2312文件怎么区分呢？我也不知道。唯一能想到的办法就是：先用一种试，如果出现乱码，就用另一种再试。)
<font color=#F09B59 style=" font-weight:bold;">值得一提的一点,utf-8存中文要比gbk存中文占用空间大50%</font>

utf-16
一律采用两个字节表示一个字符

##### 字节的编码解码
<font color=#66CC99 style=" font-weight:bold;">字符串/字符是由字节通过一定的编码方式译出的
同样,字符/字符串也能通过不同的编码方式获得到不同数量的字节</font>

**在java中，getBytes()方法如果不指定字符集，则得到的是一个操作系统默认的编码格式的字节数组；如果指定字符集，则得到的是在指定字符集下的字节数组，如：**
```java
byte[] b_gbk = "中".getBytes("gbk");
byte[] b_utf8 = "中".getBytes("utf-8");
byte[] b_iso88591 = "中".getBytes("iso-8859-1");

```
**将返回"中"这个汉字分别在gbk、utf-8、iso-8859-1编码下的字节数组表示，此时b_gbk的长度为2，b_utf8的长度为3，b_iso88591的长度为1。**

**与getBytes()方法相反，可以通过new String(byte[], charsetName)方法用指定的字符集来还原这个"中"字，如：**
```java
String s_gbk = new String(b_gbk, "gbk");
String s_utf8 = new String(b_utf8, "utf-8");
String s_iso88591 = new String(b_iso88591, "iso-8859-1");
```
通过打印出s_gbk、s_utf8、s_iso88591可以看到，s_gbk和s_utf8都是"中"，而s_iso88591是一个<font color=#66CC99 style=" font-weight:bold;">乱码</font>，这是因为iso-8859-1的编码表中，根本就没有包含汉字，因此"中".getBytes(“iso-8859-1”)得到的是"?“的字节数组表示，再通过new String(b_iso88591, “iso-8858-1”)还原得到的是”?"。

##### java中的编码与解码应对http iso编码
**有时候，为了让中文字符适应某些特殊要求(如http header要求其内容必须是iso-8859-1编码)，可能会通过将中文字符按照字节方式来编码的情况，如：**

```java
//先将中文字符转换成字节,然后将这些字节转化为传输传输过程中
//支持的编码方式的字符,最后将字符通过支持的编码方式解码为二进制后,
//通过原编码方式生成字符
String s_iso88591 = new String("中".getBytes("utf-8"), "iso-8859-1");

String s_utf8 = new String(s_iso88591.getBytes("iso-8859-1"), "utf-8");
//从而得到正确的中文汉字"中"，这样就既保证了遵守协议规定，也支持了中文。
```

