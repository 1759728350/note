##### 常见的字符编码方式
* ASCII
[详细](#####ASCII编码)
* ISO
8bit一个字符,表示256种字符
非英语国家不够用
一个字符占一个字节
* gb2312
[详细](#####gb2312-80)
* gbk/gb180303
所有汉字
两个字节表示一个字符
* Unicode
这是一个字符集,不是编码方式
* utf-8
[详细](#####utf-8编码)

* utf-16
一律采用两个字节表示一个字符



##### ASCII编码
7bit表示 2^7=128种字符
非英语国家不够用
一个字符占一个字节

详细看[../principle_of_computer_organization/王道计组/第二章_数据的表示和运算#####ASCII码的组成?](../principle_of_computer_organization/王道计组/第二章_数据的表示和运算#####ASCII码的组成?)



##### gb2312-80
从80就可以看出这套编码的简陋性和时代局限性
1980年提出来的,所以汉字不全

只能表示部分汉字

那么它是如何实现将二进制解析成字符的呢?
两个字节表示一个字符

采用类似于下面
![[Pasted image 20220827235730.png]]

两个字符,一个当横坐标,一个当纵坐标,最大化的利用了94个位来表示了七千个数

那么问题来了
你用两个字节表示一个汉字,人家哪知道呢?把你当成两个英文字母给解析出来了怎么办?
答案是不可能
因为
最开始的Ascii码第一位(最高位)为0
你汉字只需要为1就行了
但这也引申出了一个巨大问题
这里面要是有日文怎么办?
你拿这套解码有一堆日文解不出来啊
这不就有了[Unicode字符集](#####Unicode字符集)

那么如果gb2312从0开始设置编码
那原来的ascii的编码就不支持了,一些英文文档就全乱码成中文了
所以gb2312的设计时还要避开原先的ascii的编码位置
也就是说,还要对ascii编码进行兼容

一开始是加了每个字节加32避开控制位
后面又加了128避开了原本的ascii的内容

##### Unicode字符集
待施工


##### utf-8编码
变长字节表示字符
用(1~6)个字节表示一个字符
<font color=#F09B59 style=" font-weight:bold;">英文用一个字节,中文用三个字节表示一个字符</font>
windows系统下由utf-8编码的文件创建后,起始位置会有一个BOM标记
(如何标明一个文件是utf8格式呢？用windows自带的记事本创建一个utf8格式的文件，就会加上这个标记。但是，如果用ultraedit创建utf8文件，并不会加上这个标记。这个标记有个术语，叫做BOM（Byte Order Mark）。不带BOM的utf8文件和GB2312文件怎么区分呢？我也不知道。唯一能想到的办法就是：先用一种试，如果出现乱码，就用另一种再试。)
<font color=#F09B59 style=" font-weight:bold;">值得一提的一点,utf-8存中文要比gbk存中文占用空间大50%</font>


下图是utf-8编码对Unicode的实现
![[Pasted image 20220827225710.png]]



##### 字节的编码解码
<font color=#66CC99 style=" font-weight:bold;">字符串/字符是由字节通过一定的编码方式译出的
同样,字符/字符串也能通过不同的编码方式获得到不同数量的字节</font>

**在java中，getBytes()方法如果不指定字符集，则得到的是一个操作系统默认的编码格式的字节数组；如果指定字符集，则得到的是在指定字符集下的字节数组，如：**
```java
byte[] b_gbk = "中".getBytes("gbk");
byte[] b_utf8 = "中".getBytes("utf-8");
byte[] b_iso88591 = "中".getBytes("iso-8859-1");

```
**将返回"中"这个汉字分别在gbk、utf-8、iso-8859-1编码下的字节数组表示，此时b_gbk的长度为2，b_utf8的长度为3，b_iso88591的长度为1。**

**与getBytes()方法相反，可以通过new String(byte[], charsetName)方法用指定的字符集来还原这个"中"字，如：**
```java
String s_gbk = new String(b_gbk, "gbk");
String s_utf8 = new String(b_utf8, "utf-8");
String s_iso88591 = new String(b_iso88591, "iso-8859-1");
```
通过打印出s_gbk、s_utf8、s_iso88591可以看到，s_gbk和s_utf8都是"中"，而s_iso88591是一个<font color=#66CC99 style=" font-weight:bold;">乱码</font>，这是因为iso-8859-1的编码表中，根本就没有包含汉字，因此"中".getBytes(“iso-8859-1”)得到的是"?“的字节数组表示，再通过new String(b_iso88591, “iso-8858-1”)还原得到的是”?"。

##### java中的编码与解码应对http iso编码
**有时候，为了让中文字符适应某些特殊要求(如http header要求其内容必须是iso-8859-1编码)，可能会通过将中文字符按照字节方式来编码的情况，如：**

```java
//先将中文字符转换成字节,然后将这些字节转化为传输传输过程中
//支持的编码方式的字符,最后将字符通过支持的编码方式解码为二进制后,
//通过原编码方式生成字符
String s_iso88591 = new String("中".getBytes("utf-8"), "iso-8859-1");

String s_utf8 = new String(s_iso88591.getBytes("iso-8859-1"), "utf-8");
//从而得到正确的中文汉字"中"，这样就既保证了遵守协议规定，也支持了中文。
```

##### 补充: 不用字符流,只用字节流来读取utf-8编码的txt文件中的字符

```java

FileInputStream fis = new FileInputStream("new.txt");  
//txt文件是utf-8编码的,你想要让string译码译出来就需要一次给他三个字节  
byte[] bytes = new byte[3];  
int length = 0;  
int len = 0;  
while((len=fis.read(bytes)) != -1){  
    //将字节转化为字符  
    length += len;  
    System.out.print(new String(bytes,"utf-8"));  
}  
System.out.println(length);
```



##### 通过字节流转编码来解决字符流乱码问题

```java
//字符流出现乱码,可以先用字节流读取然后将字节流以对应的编码方式  
//编码为字符流,然后读取  
FileInputStream fis = new FileInputStream("new1.txt");  
InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_16LE);  
  
char[] chars = new char[2];  
int b;  
while ((b = isr.read(chars)) != -1) {  
    System.out.print(new String(chars));  
}
```

##### utf-8和uncode编码区别
![[Pasted image 20220819185457.png]]



