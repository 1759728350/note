### java中String的不可变性
String类内部定义了 final char[] value ;数组用于存储字符串数据
这里的value数组是通过<font color=#F09B59 style=" font-weight:bold;">final关键字</font>修饰的,也就说们字符串其实是一个常量,一旦在内存中申请出一个空间并且为其赋值之后这个空间中的字符串值就不可以修改了,将这个性质我们称之为不可变性

那么不可修改后
```java
//你想要将
s1 = "123"
//改为
s1 = "456"
```
怎么办?

创建一个<font color=#66CC99 style=" font-weight:bold;">新的string对象</font>返回

所以不可变性就是对象/变量只能被赋值一次
想要改就只能重新分配内存,但其引用s1会抛弃旧对象,指向新分配内存的对象

### 通过不可变性保证线程安全
当多个线程同时访问同一个资源，并且其中的一个或者多个线程对这个资源进行了<font color=#66CC99 style=" font-weight:bold;">写操作</font>，才会产生**竞态条件**。多个线程同时读同一个资源不会产生竞态条件。

下面这个代码就是线程安全的
![](img/Pasted%20image%2020220908054325.png)
为什么呢?
因为只能读不能改,里面没set方法

那如果我们要多个线程同时改呢?
那就可以用不变性,每次修改引用变量时再次创建一个新的给多个线程
多个线程由于其每个线程保存的immutableValue都不是同一个
从而避免了覆盖问题,也可以对引用加final

<font color=#F09B59 style=" font-weight:bold;">总之不可变对象永远是线程安全的</font>
![](img/Pasted%20image%2020220908054035.png)


<font color=#99CCFF style=" font-weight:bold;">实验待探究</font>
##### 模拟多线程竞争
```java
public class Erhuo {  
    public static void main(String[] args) {  
        ChangeValue changeValue = new ChangeValue(0);  
        new Thread(() -> {  
            try {  
                Thread.sleep(100);  
            } catch (InterruptedException e) {  
                throw new RuntimeException(e);  
            }            
            for (int i = 1; i <= 4000000; i++) {  
  
                changeValue.add(1);  
                System.out.println("11===>"+changeValue.getValue());  
            }        
        }).start();  
  
        new Thread(() -> {  
  
            for (int i = 1; i <= 4000000; i++) {  
                changeValue.add(1);  
                System.out.println("222==>"+changeValue.getValue());  
            }        
        }).start();  
  
    }
}
```
可以看到,循环在设置的足够大的情况下访问修改共享变量与实际的预期相差很大
![](img/Pasted%20image%2020220908064223.png)

```java
public class yihuo {  
    public static void main(String[] args) {  
        ImmutableValue immutableValue = new ImmutableValue(0);  
        new Thread() {  
            ImmutableValue addNum = null;  
            public void run() {  
                for (int i = 1; i <= 3000; i++) {  
                    addNum = immutableValue.add(i);  
                }                
                System.out.println(addNum.getValue());  
            }        
        }.start();  
  
        new Thread() {  
            ImmutableValue addNum = null;  
            public void run() {  
                for (int i = 1; i <= 3000; i++) {  
                    addNum = immutableValue.add(i);  
                }                
                System.out.println(addNum.getValue());  
            }        
        }.start();  
        System.out.println(immutableValue.getValue());  
    }
}
```

请注意add()方法以加法操作的结果作为一个新的ImmutableValue类实例返回，而不是直接对它自己的value变量进行操作。





### 引用不是线程安全的！

重要的是要记住，即使一个对象是线程安全的不可变对象，指向这个对象的引用也可能不是线程安全的。看这个例子
![](img/Pasted%20image%2020220908063240.png)

Calculator类持有一个指向ImmutableValue实例的引用。注意，通过setValue()方法和add()方法可能会改变这个引用。因此，即使Calculator类内部使用了一个不可变对象，但Calculator类本身还是可变的，因此Calculator类不是线程安全的。换句话说：<font color=#66CC99 style=" font-weight:bold;">ImmutableValue类是线程安全的，但使用它的类不是</font>。当尝试通过不可变性去获得线程安全时，这点是需要牢记的。

要使Calculator类实现线程安全，将<font color=#66CC99 style=" font-weight:bold;">getValue()、setValue()和add()方法都声明为同步方法</font>即可。



### 遇到的问题(待解决,挖坑)

<font color=#99CCFF style=" font-weight:bold;">先要把并发原理给学一下,然后是jvm,再是java并发编程</font>

你线程是内部类,访问变量时变量要加final才可以
问题是你的目的要修改他,加了final修改不了了

![](img/Pasted%20image%2020220908225654.png)

![](img/Pasted%20image%2020220908225736.png)
加了final后你获取的新对象就无法赋值了
![](img/Pasted%20image%2020220908225918.png)