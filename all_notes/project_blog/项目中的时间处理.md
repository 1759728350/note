### 为什么不用java.util.Date表示日期?
因为构造方法得出的结果太抽象了
Date无参构造底层调用的是currentTimeMillis
而currentTimeMillis获取的是从70年到现在的毫秒数
```java
public Date() {  
    this(System.currentTimeMillis());  
}
```
然而你直接输出date得到的却是
![](img/Pasted%20image%2020220907232844.png)
这格式实在太抽象

你要获取"yyyy-MM-dd HH:mm:ss"格式的日期,所以你要调用SimpleDateFormat

```java

		Date d = new Date();
		// 创建格式化对象
		// SimpleDateFormat sdf = new SimpleDateFormat();
		// 给定模式
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
		// public final String format(Date date)
		String s = sdf.format(d); 
		System.out.println(s);

```
![](img/Pasted%20image%2020220907234054.png)
我们用<font color=#F09B59 style=" font-weight:bold;">Date只能通过SimpleDateFormat将其转为需要的"yyyy-MM-dd HH:mm:ss"格式</font>
**小写hh是12小时制,大写HH是24小时制**

### 为什么不用原生java.util.Calender表示日期?
```java
/**
 * The {@link Calendar} instance used for calculating the date-time fields
 * and the instant of time. This field is used for both formatting and
 * parsing.
 *  
 * <p>Subclasses should initialize this field to a {@link Calendar}
 * appropriate for the {@link Locale} associated with this
 * <code>DateFormat</code>.
 * @serial
 */
protected Calendar calendar;


// Called from Format after creating a FieldDelegate
private StringBuffer format(Date date, StringBuffer toAppendTo,
    FieldDelegate delegate) {
    // Convert input date to time field list
    calendar.setTime(date);
	
}
```
从上面可以看出
calendar作为一个<font color=#F09B59 style=" font-weight:bold;">共享变量</font>被format方法修改了值
如果在多线程并发的情况下,线程a所获取的数可能是线程b修改过的
所以<font color=#66CC99 style=" font-weight:bold;">线程不安全</font>,容易出错
所以说是java.text.SimpleDateFormat没有考虑到线程安全问题
导致calendar对象的值会被覆盖


### 如何解决上述线程不安全问题？
<font color=#99CCFF style=" font-weight:bold;">使用ThreadLocal 为每个线程都创建一个线程独享 SimpleDateFormat 变量；</font>
需要的时候创建局部变量；
<font color=#99CCFF style=" font-weight:bold;">使用 org.apacle.commons.lang3.time.DateFormatUtils</font>
使用Joda-Time 的DateTime



### 十位和十三位时间戳
时间戳分为十位和13位
区别就是秒和毫秒

```java
Date d = new Date();
//底层调用System.currentTimeMillis()
long time = d.getTime();

//也可直接调用currentTimeMillis获得当前毫秒总数,十三位
Long time = System.currentTimeMillis();

```
十三位转十位,高精度向低精度转,除一个1000就行了
```java
Long time = System.currentTimeMillis() / 1000;
```
一般日期显示都是精确到秒就行了yyyy-MM-dd HH:mm:ss
当然你存在数据库里可以存毫秒


### 为什么要使用DateTime
因为java提供的Date和Calendar类处理时间太不好用了,且不支持并发环境
就用joda-time的包了

依赖
```xml
<dependency>
	<groupId>joda-time</groupId>
	<artifactId>joda-time</artifactId>
	<version>2.9.9</version>
</dependency>
```
构造函数非常全能
无论是Date/String/还是直接传一个时间戳都行
>DateTime()：
>这个无参的构造方法会创建一个在当前系统所在时区的当前时间，精确到毫秒
DateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute)：
这个构造方法方便快速地构造一个指定的时间，这里精确到秒，类似地其它构造方法也可以传入毫秒。
DateTime(long instant)：
这个构造方法创建出来的实例，是通过一个long类型的时间戳，它表示这个时间戳距1970-01-01T00:00:00Z的毫秒数。使用默认的时区。
DateTime(Object instant)：
这个构造方法可以通过一个Object对象构造一个实例。这个Object对象可以是这些类型：ReadableInstant, String, Calendar和Date。其中String的格式需要是ISO8601格式

### DateTime为什么能保证线程安全?
datetime的不可变性
与java.lang.String类似，它们的实例均无法修改（因为任意对其值改变的操作都会生成新的对象），这也代表了它们是线程安全的。
[线程安全及不可变性](线程安全及不可变性.md)


### 使用joda-time格式化时间
将一个时间戳转换为日期字符串
```java
String articleCreateTime = new DateTime(article.getCreateDate())
    .toString("yyyy-MM-dd HH:mm")
```
项目中可以<font color=#66CC99 style=" font-weight:bold;">数据库存储时间戳</font>
然后service读取后将其转换为日期字符串给前端

### 获取现在时间
```java
DateTime time= new DateTime();

```
### 一些直接对于日期的操作
![](img/Pasted%20image%2020220908231839.png)



### 时间存取方案1
数据库里存bigint,,20位
然后生成时间就是system.currentTime(十三位时间戳)
然后取时间就用joda-datetime去格式化查询时间