### 指令格式
操作码+地址

指令分为
* 零地址指令
有关中断,空操作
* 一地址指令
一个操作数,有两种情况,
1 将一个数加到acc中
2 对一个数进行加一/减一/取反/求补码
* 二地址指令
两个操作数 a + b这样的算术运算以及逻辑运算
* 三地址指令
比二地址多了一个写入地址位置,二地址指令是将a + b后将结果写入到a
* 四地址指令
多了一个跳转地址,指定了下一个指令的位置
![](img/Pasted%20image%2020220903005005.png)
![](img/Pasted%20image%2020220903005036.png)

### 字长问题
机器字长:由cpu中的alu算数逻辑单元来决定位数
存储字长:由存储器中/cpu中的MDR位数相同,一个存储单元的大小
指令字长:一条指令的长度,一般是机器字长的倍数


### 指令种类
* 数据传送
LOAD 把存储器里的数加载到寄存器
STORE   寄存器里的数加载到存储器
* 算术逻辑操作
* 移位操作
* 转移操作
* 输入输出操作
![](img/Pasted%20image%2020220903005115.png)

### 扩展操作码的设计
我们知道一个指令是由操作码和操作数组成
操作码表示这个指令的类型
操作码的位数会影响后续操作数的存储空间
那现在有两种操作码的设计方案
* 定长操作码
* 扩展操作码

定长咱们先不讨论,就是单纯排列组合
不定长设计就比较厉害啦
用到了类似<font color=#F09B59 style=" font-weight:bold;">霍夫曼编码(短编码前缀必须不能和长编码前缀一样,否则造成歧义)</font>

![](img/Pasted%20image%2020220903192643.png)


### 指令的寻址方式
寻址方式
##### 顺序寻址
一条指令执行完毕后PC寄存器+1,执行下一条指令
##### 跳跃寻址
诸如JMP汇编指令,PC被改为JMP的参数,跳到目的地址执行指令

![](img/Pasted%20image%2020220904035920.png)

这里右提到了字长的概念,主存按字编址
这个字指的是存储字长,由MDR寄存器决定

那么加入指令字长等于存储字长,即一个存储单元存一个指令
那么(PC) + 1 -> PC中的1相当于一个指令字长

### 数据的寻址

根据地址码去找数据,找数据的方式有分了多种
所以又要给地址码分出一个寻址特征

![](img/Pasted%20image%2020220904041127.png)

一地址指令和二地址指令的字段结构
![](img/Pasted%20image%2020220904041100.png)

不同寻址特征访问内存次数
![](img/Pasted%20image%2020220904041954.png)

根据地址找到的存储单元里存的不一定是值,还会是地址


##### 直接寻址
地址码存的地址里放的就是数据
##### 间接寻址
地址码存的地址放的又是另一个地址
简单来说就是c语言里的多重指针
![](img/Pasted%20image%2020220904042132.png)

间接寻址的方式可以表示更大的范围,原先的地址码和只占了一个指令字长的一部分
现在其存的地址指向的内存单元可以存下一个内存字长的地址表示范围,
表示范围显然更大了
##### 基址寻址
用于<font color=#99CCFF style=" font-weight:bold;">操作系统多程序并发的基础</font>
其用到寄存器BR(base register)
这个BR寄存器只能由操作系统修改
这个BR的值是程序的起始位置,由<font color=#99CCFF style=" font-weight:bold;">操作系统的PCB控制</font>

每次寻址PC加上基址去寻址,使得每次切换不同的程序都能找到对应程序所需要的数据
因为多个程序是在内存里浮动的,程序在内存中位置会变化
但利用基址你每次换到该程序进行执行都能顺利的从上一程序的内存中切出
然后进入改程序找到相应位置的指令
一句话,<font color=#F09B59 style=" font-weight:bold;">方便多程序切换并发</font>

![](img/Pasted%20image%2020220904184541.png)

##### 变址寻址
针对于数组元素的寻址
寄存器是IX(index register),没有特殊要求,程序员可以改
变址寻址可以优化重复多次有规律的指令进行优化
利用跳转指令重复指令位置,然后再对index register加一
实现类似for循环的效果

![](img/Pasted%20image%2020220904185400.png)
![](img/Pasted%20image%2020220904185413.png)

##### 相对寻址
相对于PC的值加减进行移动
主要用于<font color=#66CC99 style=" font-weight:bold;">跳转指令</font>
注意PC是先加1灾跳转的
代码位置不固定,利用PC的相对位置寻址更方便
这里涉及到<font color=#99CCFF style=" font-weight:bold;">分段问题</font>
![](img/Pasted%20image%2020220904190502.png)

##### 堆栈寻址
利用栈这种数据结构,后进先出
使用的寄存器是SP(stack pointer)
<font color=#66CC99 style=" font-weight:bold;">每次pop出一个栈顶元素后SP都会加1</font>(栈顶低地址)
然后计算出来的结果写回到栈时,SP-1
<font color=#99CCFF style=" font-weight:bold;">堆栈可用于函数调用时保存当前函数的相关信息参考数据结构“算法空间复杂度”</font>
![](img/Pasted%20image%2020220904193925.png)

软堆栈
程序主要用主存里划一块当做堆栈用,用寄存器作为堆栈太过奢侈
利用主存<font color=#66CC99 style=" font-weight:bold;">需要一次访存操作</font>
![](img/Pasted%20image%2020220904194029.png)