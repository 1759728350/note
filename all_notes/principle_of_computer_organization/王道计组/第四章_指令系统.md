##### 指令格式
操作码+地址

指令分为
* 零地址指令
有关中断,空操作
* 一地址指令
一个操作数,有两种情况,
1 将一个数加到acc中
2 对一个数进行加一/减一/取反/求补码
* 二地址指令
两个操作数 a + b这样的算术运算以及逻辑运算
* 三地址指令
比二地址多了一个写入地址位置,二地址指令是将a + b后将结果写入到a
* 四地址指令
多了一个跳转地址,指定了下一个指令的位置
![](img/Pasted%20image%2020220903005005.png)
![](img/Pasted%20image%2020220903005036.png)

##### 字长问题
机器字长:由cpu中的alu算数逻辑单元来决定位数
存储字长:由存储器中/cpu中的MDR位数相同,一个存储单元的大小
指令字长:一条指令的长度,一般是机器字长的倍数


##### 指令种类
* 数据传送
LOAD 把存储器里的数加载到寄存器
STORE   寄存器里的数加载到存储器
* 算术逻辑操作
* 移位操作
* 转移操作
* 输入输出操作
![](img/Pasted%20image%2020220903005115.png)

##### 扩展操作码的设计
我们知道一个指令是由操作码和操作数组成
操作码表示这个指令的类型
操作码的位数会影响后续操作数的存储空间
那现在有两种操作码的设计方案
* 定长操作码
* 扩展操作码

定长咱们先不讨论,就是单纯排列组合
不定长设计就比较厉害啦
用到了类似<font color=#F09B59 style=" font-weight:bold;">霍夫曼编码(短编码前缀必须不能和长编码前缀一样,否则造成歧义)</font>

![](img/Pasted%20image%2020220903192643.png)


##### 指令的寻址方式
寻址方式
* 顺序寻址
一条指令执行完毕后PC寄存器+1,执行下一条指令
* 跳跃寻址
诸如JMP汇编指令,PC被改为JMP的参数,跳到目的地址执行指令

![](img/Pasted%20image%2020220904035920.png)

这里右提到了字长的概念,主存按字编址
这个字指的是存储字长,由MDR寄存器决定

那么加入指令字长等于存储字长,即一个存储单元存一个指令
那么(PC) + 1 -> PC中的1相当于一个指令字长

##### 数据的寻址

根据地址码去找数据,找数据的方式有分了多种
所以又要给地址码分出一个寻址特征

![](img/Pasted%20image%2020220904041127.png)

一地址指令和二地址指令的字段结构
![](img/Pasted%20image%2020220904041100.png)

不同寻址特征访问内存次数
![](img/Pasted%20image%2020220904041954.png)

根据地址找到的存储单元里存的不一定是值,还会是地址
* 直接寻址
地址码存的地址里放的就是数据
* 间接寻址
地址码存的地址放的又是另一个地址
简单来说就是c语言里的多重指针
![](img/Pasted%20image%2020220904042132.png)

间接寻址的方式可以表示更大的范围,原先的地址码和只占了一个指令字长的一部分
现在其存的地址指向的内存单元可以存下一个内存字长的地址表示范围,
表示范围显然更大了