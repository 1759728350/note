#### cortex-m4工作状态  
处理模式和线程模式之间相互切换  
处理器处于异常和中断,会进入处理器模式,该模式有特权访问等级  
线程模式也可以有,访问等级由一个寄存器来控制   
调试状态:调试状态下可以修改寄存器中的值  
Thumb状态:正常运行时处理器的状态  

#### 通用寄存器
R0-R7底端寄存器    支持16位/32位操作数  
R8-R12高端寄存器  支持32位操作数  
R13存堆栈指针SP    
R14连接寄存器,存储要调用的子函数地址  
R15程序计数器PC,存储下一条要执行的指令地址  

#### m4指令集
ARM指令集,32位  
thumb指令集,有些16位,有些32位,节省存储空间但效率没有ARM指令集高  
Thumb指令集不完整,需要配合ARM指令集一起使用  
contex-m一般用thumb指令集  

#### 访问寄存器
```c
#define GPLOA_BASE ((unsigned int)0x40020000)
#define GPLOA_ODR (GPLOA_BASE + 0X14)

/*在嵌入式系统中，无符号整型(unsigned int)常用于表示寄存器、硬件状态等状态信息。因为这些状态信息通常都是正整数或者0，不会有负数，所以使用无符号整型更为合适。同时，嵌入式系统中的内存通常都是有限的，使用无符号整型可以节省存储空间。此外，在处理位操作时，使用无符号整型可以更容易地控制位数，避免符号位的干扰。
*/
val = *(unsigned int *)GPLOA_ODR;//读操作

//光有一个值的地址是什么都做不了的
//根据地址读写值是需要该值的指针
//该值指针怎么获取?-->对地址转换类型,定义类型
//然后用取地址符*来取数
*(unsigned int *) GPLOA_ODR = val;//写操作
```
也可以写成
```c
#define GPLOA_BASE ((unsigned int)0x40020000)
//将ODR直接写成  地址转换后的指针且取完地址的值
#define GPLOA_ODR (*(unsigned int *)(GPLOA_BASE + 0X14))

//这样就可以直接读写该值了
val = GPLOA_ODR;  //读操作
GPLOA_ODR = val;  //写操作
```

#### 第二种访问外设寄存器的方法
用结构体封装寄存器  
```c
//`uint32_t` 是一个具有固定大小的无符号 32 位整数类型，可以确保在所有平
//台上具有相同的大小和范围。而 `unsigned int` 是一个通用无符号整数类型，在不
//同平台和编译器上可能具有不同的大小。如果需要确保精确的大小和跨平台兼容性，
//则应优先使用 `uint32_t`。
typedef struct{
	uint32_t MODER;
	uint32_t OTYPER;
	uint32_t PUPDR;
	uint32_t IDR;
	uint32_t ODR;
}GPIO_TypeDef;


#define GPIOA_BASE ((unsigned int)0x40020000)
//转换为结构体对应的指针
#define GPLOA ((GPIO_TypeDef *)GPLOA_BASE)

//结构体指针通过->来访问成员变量
GPLOA->ODR = 0x22;
```

#### stm32启动流程

复位向量
通常是一个特殊的向量表，其中包含一系列指向不同功能的指针。当系统启动时，CPU会自动从复位向量表中读取第一个指针所指向的地址，并开始执行复位处理程序。该处理程序会初始化堆栈指针、时钟、中断控制器等，并将控制权交还给应用程序。