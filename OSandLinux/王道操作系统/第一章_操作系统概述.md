### 操作系统的存在意义
* 并发执行程序
* 虚拟化,抽象化硬件资源为可供调用的接口

### 多道批处理系统
##### 单道批处理
![](img/Pasted%20image%2020220914234103.png)
##### 多道批处理系统存在的意义是什么?
因为多个硬件的处理速度不一致
没必要等待每个硬件处理完毕再去执行下一个程序
可以更高效地利用硬件的每一个时刻
计算机并不是一个整体
充分利用每一个个体的资源,不浪费
![](img/Pasted%20image%2020220914234142.png)


### 分时操作系统
解决人机交互的问题
一个程序的执行,用户是可以介入的
用户之所以可以介入是因为剥夺式[剥夺式调度](第二章_进程与线程####剥夺和非剥夺调度 )
一个程序不仅要在空间上能打碎节省内存的同时,还要能在时间上打碎
程序只有时间上被打碎后才能被人为介入
当然一些原子操作打不碎

这就要用到分时操作系统
计算机分配给每个程序时间片,执行了若干个时间片后切换执行其他用户交互程序


### 内核态和用户态
cpu有两种状态，“内核态”和“用户态”
处于内核态时，说明此时正在运行的是内核程序，
此时可以执行特权指令处于用户态时，
说明此时正在运行的是应用程序此时只能执行特权指令

CPU中有一个寄存器叫程序状态字寄存器: PSWjz2其中有个二进制位，1表示“内核态”，0表示“用户态”
##### 状态切换
系统在执行特权指令时
会检查PSW,若为内核态则执行指令
若为用户态则拒绝执行,并发出中断信号夺会控制权给其他程序
![](img/Pasted%20image%2020220915000941.png)
内核态→用户态:执行一条特权指令修改PSW的标志位为“用户态”，这个动作意味着<font color=#66CC99 style=" font-weight:bold;">操作系统将主动让出CPU使用权</font>
用户态→内核态:由“中断”引发，硬件自动完成变态过程，触发中断信号意味着<font color=#66CC99 style=" font-weight:bold;">操作系统将强行夺回CPU的使用权</font>
![](img/Pasted%20image%2020220915001400.png)


### 中断
<font color=#F09B59 style=" font-weight:bold;">用户态切换到内核态</font>
![](img/Pasted%20image%2020220915004726.png)


##### 中断存在的意义
中断是<font color=#66CC99 style=" font-weight:bold;">操作系统内核</font>夺回cpu使用权的唯一途径
没有中断,<font color=#66CC99 style=" font-weight:bold;">cpu</font>就只能运行一直运行之前的程序
管理者拿不到cpu权限那么,
管理者就没权限给别的程序去被cpu执行了

##### 内中断(异常)
来源于cpu内部的中断,也成为了<font color=#FF6666* style=" font-weight:bold;">异常</font>
* 用户态下执行特权指令(超过权限)
* 指令抛异常(程序出bug,停了)
* 用户态切换内核态执行陷入指令,<font color=#66CC99 style=" font-weight:bold;">交还处理器给系统</font>,<font color=#F09B59 style=" font-weight:bold;">执行系统调用</font>
![](img/Pasted%20image%2020220915003436.png)
![](img/Pasted%20image%2020220915003637.png)

##### 什么是陷入指令?
入指令_是指用户程序所依靠的指令,用于发起<font color=#66CC99 style=" font-weight:bold;">系统调用</font>,请求操作系统提供服务
陷入指令有其中一点特殊在于,其只能在用户态下执行,而不可以在核心态下执行
因为就是要用户态切换到内核态嘛

##### 外中断
来自于cpu外部其他硬件的中断
* 时钟中断----分时操作系统的基石
* io中断-------读写外部io设备
![](img/Pasted%20image%2020220915004212.png)

##### 中断的实现原理
中断是操作系统内核态下的程序
建立一个关于不同中断信号的处理表
根据不同中断信号去调用相应情况下的中断处理程序
![](img/Pasted%20image%2020220915004926.png)


### 系统调用
##### 什么是系统调用
<font color=#66CC99 style=" font-weight:bold;">操作系统封装的文件管理/io操作/内存管理等接口</font>
<font color=#66CC99 style=" font-weight:bold;">用户态下需要陷入指令触发中断进入内核态后才能调用</font>
![](img/Pasted%20image%2020220915045617.png)

##### 为什么用系统调用?
应用程序通过系统调用请求操作系统的服务。
而系统中的各种<font color=#66CC99 style=" font-weight:bold;">共享资源都由操作系统内核统一掌管</font>，
因此凡是与共享资源有关的操作（如存储分配、i/o操作、文件管理等)，
都必须通过系统调用的方式向操作系统内核提出服务请求，
由操作系统内核代为完成。
这样可以保证系统的稳定性和安全性，
防止用户进行非法操作。

##### 系统调用的过程
![](img/Pasted%20image%2020220915050603.png)
一段程序在用户态执行时需要系统调用,此时会执行一条<font color=#F09B59 style=" font-weight:bold;">陷入指令</font>
cpu执行陷入指令,会触发内中断,<font color=#66CC99 style=" font-weight:bold;">进入内核态</font>
操作系统获得cpu控制权
执行相应的系统调用
然后返回结果,系统把cpu控制权给应用程序
### bios的作用
<font color=#66CC99 style=" font-weight:bold;">bios是cpu启动操作系统的引导程序</font>
BIOS全名 Basic Input Output System即**“基本输出与输入系统”**，是计算机启动时加载的第一个软件。它是储存在主板上的不需要电源的记忆体(芯片)中的一小段代码,是一个程序。我们通常称之为主板“固件”，因为**它是软件和硬件之间的桥梁，没有它的话电脑就无法开机。**
![](img/Pasted%20image%2020220915160926.png)


### 虚拟机的存在意义
多个应用程序在一个操作系统上可能存在一些安全问题
客观上我们不希望这些个程序在一个系统资源上运行
所以我们才分出资源去构建虚拟机,
这样我们一台机器可以有多个操作系统资源

而虚拟机管理程序的作用就是模拟cpu时间片分配,磁盘分配,内存分配等硬件资源

##### 两种类型的虚拟机
* 虚拟机直接运行在硬件上,即裸机上
所有资源在<font color=#66CC99 style=" font-weight:bold;">未经任何虚拟化的情况下</font>使用
可以理解为虚拟机监控管理程序本身就是个操作系统

* 虚拟机运行在宿主操作系统上
类似于套娃,在原有操作系统上运行多个vm
每个vm都有一个操作系统
像宿主系统创建了<font color=#66CC99 style=" font-weight:bold;">虚拟内存</font>,虚拟机下的操作系统又划分了多块虚拟内存
多次映射导致运行效率会比较慢

所有运行在vm上的应用程序在使用特权指令
此时会切换到vm上操作系统的内核态,向下调用硬件
而虚拟机管理程序就是来模拟硬件资源分配的
让运行在vm上的操作系统<font color=#66CC99 style=" font-weight:bold;">误认为这就是运行在"裸机"</font>上的

![](img/Pasted%20image%2020220915164235.png)

* 第三种容器技术(扩充)
利用操作系统进程隔离

##### 虚拟机迁移
当然第二种迁移性更好,导出为<font color=#F09B59 style=" font-weight:bold;">iso</font>文件后,存到硬盘里
插到<font color=#F09B59 style=" font-weight:bold;">任何电脑都能用</font>,而且之前下载的应用程序也可以使用

##### 指令分级
上面涉及到了指令分级
之前学到的特权指令和执行在用户态的普通指令
可以细分为更多级别
不至于每个特权指令都要到最底层才能执行