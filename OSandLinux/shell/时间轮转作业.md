## 运行结果

![image-20231117110844962](D:\elecbook\OSandLinux\shell\${imgs}\image-20231117110844962.png)

## 流程图



## 代码

```c
#include <stdio.h>
#include <stdlib.h>

struct PCB{                 // 定义进程控制块（Process Control Block）
    int pid;                // 进程标识符
    int rr;                 // 已运行时间
    int time;               // 进程要求运行时间
    char sta;               // 进程的状态
    struct PCB *next;       // 链接指针
};

struct PCB pcb1,pcb2,pcb3,pcb4,pcb5,*tail,*head,*rp;   // 定义进程以及链表的头尾指针

void init(){                     // 初始化各个进程的运行时间
    int time;

    pcb1.pid = 1;		//设置每个进程pid
    pcb2.pid = 2;
    pcb3.pid = 3;
    pcb4.pid = 4;
    pcb5.pid = 5;

    pcb1.rr = pcb2.rr = pcb3.rr = pcb4.rr = pcb5.rr = 0;  // 将已运行时间初始化为0
    pcb1.sta = pcb2.sta = pcb3.sta = pcb4.sta = pcb5.sta = 'w';  // 将状态初始化为等待态

    printf("请输入进程p1需要运行的时间:");
    scanf("%d", &time);    // 输入进程p1的运行时间
    pcb1.time = time;

    printf("请输入进程p2需要运行的时间:");
    scanf("%d", &time);    // 输入进程p2的运行时间
    pcb2.time = time;

    printf("请输入进程p3需要运行的时间:");
    scanf("%d", &time);    // 输入进程p3的运行时间
    pcb3.time = time;

    printf("请输入进程p4需要运行的时间:");
    scanf("%d", &time);    // 输入进程p4的运行时间
    pcb4.time = time;

    printf("请输入进程p5需要运行的时间:");
    scanf("%d", &time);    // 输入进程p5的运行时间
    pcb5.time = time;

    pcb1.next = &pcb2;    // 将进程按顺序连接成一个循环链表
    pcb2.next = &pcb3;
    pcb3.next = &pcb4;
    pcb4.next = &pcb5;
    pcb5.next = &pcb1;

    head = &pcb1;   // 初始化头指针为pcb1
    tail = &pcb5;   // 初始化尾指针为pcb5
}

void printf1(){     // 显示表头
    printf("+---------------|---------------|---------------|---------------+\n");
    printf("|\tpid\t|\trr\t|\ttime\t|\tSTA\t|\n");
    printf("|---------------|---------------|---------------|---------------|\n");
}

void printf2(){     // 显示各个进程的初始状态
    printf("processes p%d running\n", head->pid);
    printf1();
    printf("|\t%d\t|\t%d\t|\t%d\t|\t%c\t|\n", head->pid, head->rr, head->time, head->sta);
    printf("|---------------|---------------|---------------|---------------|\n");

    rp = head;    // 用临时指针指向头指针所指向的进程

    while(rp != tail){   // 遍历整个进程链表
        rp = rp->next;
        printf("|\t%d\t|\t%d\t|\t%d\t|\t%c\t|\n", rp->pid, rp->rr, rp->time, rp->sta);
        printf("|---------------|---------------|---------------|---------------|\n");
    }
}

void operation(){     // 运行进程
    int flag = 1;	

    while(flag <= 5){    // 循环执行五次，模拟进程的执行过程
        head->rr++;    // 当前进程的已运行时间加1

        if((head->rr == head->time) || (head->time == 0)){   // 如果已运行时间等于要求运行时间或要求运行时间为0
            tail->sta = 'w';   // 将进程状态设置为等待态
            head->sta = 'f';   // 将进程状态设置为执行态
            printf2();   // 显示当前进程队列状态
            head = head->next;   // 头指针指向下一个进程
            tail->next = head;   // 更新尾指针
            flag++;   // 标志位加1
        }
        else{
            tail->sta = 'w';   // 将进程状态设置为等待态
            head->sta = 'r';   // 将进程状态设置为就绪态
            printf2();   // 显示当前进程队列状态
            tail = head;   // 更新尾指针
            head = head->next;   // 头指针指向下一个进程
        }
    }
}

int main(){
    init();     // 初始化进程队列
    printf2();  // 显示初始状态
    operation();   // 模拟进程的运行

    return 0;
}
```



