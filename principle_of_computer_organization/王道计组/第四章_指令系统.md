### 指令格式
操作码+地址

指令分为
* 零地址指令
有关中断,空操作
* 一地址指令
一个操作数,有两种情况,
1 将一个数加到acc中
2 对一个数进行加一/减一/取反/求补码
* 二地址指令
两个操作数 a + b这样的算术运算以及逻辑运算
* 三地址指令
比二地址多了一个写入地址位置,二地址指令是将a + b后将结果写入到a
* 四地址指令
多了一个跳转地址,指定了下一个指令的位置
![](img/Pasted%20image%2020220903005005.png)
![](img/Pasted%20image%2020220903005036.png)

### 字长问题
机器字长:由cpu中的alu算数逻辑单元来决定位数
存储字长:由存储器中/cpu中的MDR位数相同,一个存储单元的大小
指令字长:一条指令的长度,一般是机器字长的倍数


### 指令种类
* 数据传送
LOAD 把存储器里的数加载到寄存器
STORE   寄存器里的数加载到存储器
* 算术逻辑操作
* 移位操作
* 转移操作
* 输入输出操作
![](img/Pasted%20image%2020220903005115.png)

### 扩展操作码的设计
我们知道一个指令是由操作码和操作数组成
操作码表示这个指令的类型
操作码的位数会影响后续操作数的存储空间
那现在有两种操作码的设计方案
* 定长操作码
* 扩展操作码

定长咱们先不讨论,就是单纯排列组合
不定长设计就比较厉害啦
用到了类似<font color=#F09B59 style=" font-weight:bold;">霍夫曼编码(短编码前缀必须不能和长编码前缀一样,否则造成歧义)</font>

![](img/Pasted%20image%2020220903192643.png)


### 指令的寻址方式
寻址方式
##### 顺序寻址
一条指令执行完毕后PC寄存器+1,执行下一条指令
##### 跳跃寻址
诸如JMP汇编指令,PC被改为JMP的参数,跳到目的地址执行指令

![](img/Pasted%20image%2020220904035920.png)

这里右提到了字长的概念,主存按字编址
这个字指的是存储字长,由MDR寄存器决定

那么加入指令字长等于存储字长,即一个存储单元存一个指令
那么(PC) + 1 -> PC中的1相当于一个指令字长

### 数据的寻址

根据地址码去找数据,找数据的方式有分了多种
所以又要给地址码分出一个寻址特征

![](img/Pasted%20image%2020220904041127.png)

一地址指令和二地址指令的字段结构
![](img/Pasted%20image%2020220904041100.png)

不同寻址特征访问内存次数
![](img/Pasted%20image%2020220904041954.png)

根据地址找到的存储单元里存的不一定是值,还会是地址


##### 直接寻址
地址码存的地址里放的就是数据
##### 间接寻址
地址码存的地址放的又是另一个地址
简单来说就是c语言里的多重指针
![](img/Pasted%20image%2020220904042132.png)

间接寻址的方式可以表示更大的范围,原先的地址码和只占了一个指令字长的一部分
现在其存的地址指向的内存单元可以存下一个内存字长的地址表示范围,
表示范围显然更大了
##### 基址寻址
用于<font color=#99CCFF style=" font-weight:bold;">操作系统多程序并发的基础</font>
其用到寄存器BR(base register)
这个BR寄存器只能由操作系统修改
这个BR的值是程序的起始位置,由<font color=#99CCFF style=" font-weight:bold;">操作系统的PCB控制</font>

每次寻址PC加上基址去寻址,使得每次切换不同的程序都能找到对应程序所需要的数据
因为多个程序是在内存里浮动的,程序在内存中位置会变化
但利用基址你每次换到该程序进行执行都能顺利的从上一程序的内存中切出
然后进入改程序找到相应位置的指令
一句话,<font color=#F09B59 style=" font-weight:bold;">方便多程序切换并发</font>

![](img/Pasted%20image%2020220904184541.png)

##### 变址寻址
针对于数组元素的寻址
寄存器是IX(index register),没有特殊要求,程序员可以改
变址寻址可以优化重复多次有规律的指令进行优化
利用跳转指令重复指令位置,然后再对index register加一
实现类似for循环的效果

![](img/Pasted%20image%2020220904185400.png)
![](img/Pasted%20image%2020220904185413.png)

##### 相对寻址
相对于PC的值加减进行移动
主要用于<font color=#66CC99 style=" font-weight:bold;">跳转指令</font>
注意PC是先加1灾跳转的
代码位置不固定,利用PC的相对位置寻址更方便
这里涉及到<font color=#99CCFF style=" font-weight:bold;">分段问题</font>
![](img/Pasted%20image%2020220904190502.png)

##### 堆栈寻址
利用栈这种数据结构,后进先出
使用的寄存器是SP(stack pointer)
<font color=#66CC99 style=" font-weight:bold;">每次pop出一个栈顶元素后SP都会加1</font>(栈顶低地址)
然后计算出来的结果写回到栈时,SP-1
<font color=#99CCFF style=" font-weight:bold;">堆栈可用于函数调用时保存当前函数的相关信息参考数据结构“算法空间复杂度”</font>
![](img/Pasted%20image%2020220904193925.png)

软堆栈
程序主要用主存里划一块当做堆栈用,用寄存器作为堆栈太过奢侈
利用主存<font color=#66CC99 style=" font-weight:bold;">需要一次访存操作</font>
![](img/Pasted%20image%2020220904194029.png)


### 汇编和指令集
<font color=#99CCFF style=" font-weight:bold;">这一节主要对汇编语言进行一次简单梳理以后具体去回去学一遍64位的</font>

#### 高级语言和机器语言的关系
机器语言和汇编指令一一对应
高级语言会编译为多个汇编指令
![](img/Pasted%20image%2020220905143236.png)

#### 什么是x86汇编语言
适用于x86架构的cpu的汇编语言
对于8086/80286/80386等cpu指令集的代码实现
上面的几个处理器不是16位就是32位的

这与后面amd提出来的x64架构做出区分


#### x86架构的cpu有哪些寄存器
寄存器前面带E是extended,扩展寄存器,EAX比AX位数大一倍
EAX32位,AX16位,AH,AL是八位
比如8086cpu是16位,80286是32位cpu,他们都支持x86架构的指令集

★ EAX 是"累加器"(accumulator), 它是很多加法乘法指令的缺省寄存器。
★ EBX 是"基地址"(base)寄存器, 在内存寻址时存放基地址。
★ ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。
★ ESI/EDI分别叫做"源/目标索引寄存器"(source/destination index)。
★ ESP：寄存器存放当前线程的**栈顶**指针  
★ EBP：寄存器存放当前线程的**栈底**指针
![](img/Pasted%20image%2020220905150013.png)
![](img/Pasted%20image%2020220905150332.png)

#### 常用的x86汇编指令
![](img/Pasted%20image%2020220905150413.png)
![](img/Pasted%20image%2020220905150430.png)
![](img/Pasted%20image%2020220905150441.png)


#### 指令集
指令集是什么?
指令集就是指令的集合,是一种cpu接口
cpu的电路设计就是对指令集的实现
一边是电路设计另一边是机器码/汇编代码

常见指令集有
x86
x64
arm


#### 操作系统位数
由其cpu的指令集决定
操作系统位数 = 其所依赖的指令集位数 <= CPU位数
记住:计算机的演进过程中从来都是软件去妥协适应硬件

#### AT&T格式和intel格式
一个时linux/unix汇编指令的格式
一个时windows汇编指令的格式
指令的目的数和源数正好相反
![](img/Pasted%20image%2020220905150819.png)
![](img/Pasted%20image%2020220905150914.png)


#### 汇编中分支逻辑的实现
* 无条件转移指令jmp
* 条件转移指令jxx

条件转移指令比无条件多了一个比较的过程
这里寄存器IP(instruction pointer)和PC是一个东西

##### 无条件转移指令
可以用一个标志来锚定跳转位置
类似于goto

![](img/Pasted%20image%2020220905155416.png)

##### 条件转移指令
条件转移指令比无条件转移指令多一个比较行为
下面是常见的比较指令,利用这个比较指令,可以实现if分支
对于else代码块的跳转
![](img/Pasted%20image%2020220905155813.png)

##### 用条件转移指令实现if-else
![](img/Pasted%20image%2020220905160004.png)

##### 用条件转移指令实现循环
![](img/Pasted%20image%2020220905160452.png)

##### 用loop指令实现循环
我们知道ecx是计数器寄存器,loop指令专门用来递减循环用的
dec ecx就是对ecx的值减一
然后比较条件决定是否跳转还是执行下一步
![](img/Pasted%20image%2020220905161013.png)

#### CISC和RISC
complex instruction set computer
reduced(精简的) instruction set computer

前者主要用于电脑,指令多,臃肿,因为80%时候使用的都是那20%的指令
而且那些多余的指令实现方式效率也不一定高
后者主要用于手机,不同于RISC在add的时候就能一边从内存读取,一边加数
他是把RISC的指令打得更碎了

总而言之RISC类似于c++的库函数,CISC类似于c